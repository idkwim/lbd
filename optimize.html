

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Backend Optimization &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.3.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="LLD for Cpu0" href="lld.html" />
    <link rel="prev" title="Run backend" href="runbackend.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Backend Optimization</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="runbackend.html">Run backend</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lld.html">LLD for Cpu0</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="backend-optimization">
<span id="sec-optimize"></span><h1>Backend Optimization<a class="headerlink" href="#backend-optimization" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduce how to do backend optimization in LLVM first.
Next we do optimization via redesign instruction sets with hardware level to
do optimization by create a efficient RISC CPU which aim to C/C++ high level
language.</p>
<div class="section" id="cpu0-backend-optimization-remove-useless-jmp">
<h2>Cpu0 backend Optimization: Remove useless JMP<a class="headerlink" href="#cpu0-backend-optimization-remove-useless-jmp" title="Permalink to this headline">¶</a></h2>
<p>LLVM use functional pass in code generation and optimization.
Following the 3 tiers of compiler architecture, LLVM did much optimization in
middle tier of which is LLVM IR, SSA form.
In spite of this middle tier optimization, there are opportunities in
optimization which depend on backend features.
Mips fill delay slot is an example of backend optimization used in pipeline
RISC machine.
You can modify from Mips this part if your backend is a pipeline RISC with
delay slot.
We apply the &#8220;delete useless jmp&#8221; unconditional branch instruction in Cpu0
backend optimization in this section.
This algorithm is simple and effective as a perfect tutorial in optimization.
You can understand how to add a optimization pass and design your complicate
optimization algorithm on your backend in real project.</p>
<p>Chapter12_1/ support this optimization algorithm include the added codes as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_1/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="p">...</span>
  <span class="n">Cpu0DelUselessJMP</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_1/Cpu0.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
  <span class="n">FunctionPass</span> <span class="o">*</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>

<span class="c1">// Cpu-TargetMachine.cpp</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">addPreEmitPass</span><span class="p">();</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="c1">// Implemented by targets that want to run passes immediately before</span>
<span class="c1">// machine code is emitted. return true if -print-machineinstrs should</span>
<span class="c1">// print out the code after the passes.</span>
<span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addPreEmitPass</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span> <span class="o">=</span> <span class="n">getCpu0TargetMachine</span><span class="p">();</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">TM</span><span class="p">));</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_1/Cpu0DelUselessJMP.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0DelUselessJMP.cpp - Cpu0 DelJmp -------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Simple pass to fills delay slots with useful instructions.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;del-jmp&quot;</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/SmallSet.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Statistic.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">STATISTIC</span><span class="p">(</span><span class="n">NumDelJmp</span><span class="p">,</span> <span class="s">&quot;Number of useless jmp deleted&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">EnableDelJmp</span><span class="p">(</span>
  <span class="s">&quot;enable-cpu0-del-useless-jmp&quot;</span><span class="p">,</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Delete useless jmp instructions: jmp 0.&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">);</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">DelJmp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionPass</span> <span class="p">{</span>

    <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">*</span><span class="n">TII</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
    <span class="n">DelJmp</span><span class="p">(</span><span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">MachineFunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">),</span> <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span> <span class="n">TII</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">getInstrInfo</span><span class="p">())</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;Cpu0 Del Useless jmp&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">runOnMachineBasicBlock</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBBN</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">EnableDelJmp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MachineFunction</span><span class="o">::</span><span class="n">iterator</span> <span class="n">FJ</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">FJ</span> <span class="o">!=</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="n">FJ</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">FJ</span> <span class="o">==</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">MachineFunction</span><span class="o">::</span><span class="n">iterator</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">FE</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
             <span class="n">FJ</span> <span class="o">!=</span> <span class="n">FE</span><span class="p">;</span> <span class="o">++</span><span class="n">FI</span><span class="p">,</span> <span class="o">++</span><span class="n">FJ</span><span class="p">)</span>
          <span class="c1">// In STL style, F.end() is the dummy BasicBlock() like &#39;\0&#39; in </span>
          <span class="c1">//  C string. </span>
          <span class="c1">// FJ is the next BasicBlock of FI; When FI range from F.begin() to </span>
          <span class="c1">//  the PreviousBasicBlock of F.end() call runOnMachineBasicBlock().</span>
          <span class="n">Changed</span> <span class="o">|=</span> <span class="n">runOnMachineBasicBlock</span><span class="p">(</span><span class="o">*</span><span class="n">FI</span><span class="p">,</span> <span class="o">*</span><span class="n">FJ</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">};</span>
  <span class="kt">char</span> <span class="n">DelJmp</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// end of anonymous namespace</span>

<span class="kt">bool</span> <span class="n">DelJmp</span><span class="o">::</span>
<span class="n">runOnMachineBasicBlock</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBBN</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span>
    <span class="n">I</span><span class="o">--</span><span class="p">;</span>	<span class="c1">// set I to the last instruction</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
    
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JMP</span> <span class="o">&amp;&amp;</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getMBB</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">MBBN</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// I is the instruction of &quot;jmp #offset=0&quot;, as follows,</span>
    <span class="c1">//     jmp	$BB0_3</span>
    <span class="c1">// $BB0_3:</span>
    <span class="c1">//     ld	$4, 28($sp)</span>
    <span class="o">++</span><span class="n">NumDelJmp</span><span class="p">;</span>
    <span class="n">MBB</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>	<span class="c1">// delete the &quot;JMP 0&quot; instruction</span>
    <span class="n">Changed</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>	<span class="c1">// Notify LLVM kernel Changed</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>

<span class="p">}</span>

<span class="c1">/// createCpu0DelJmpPass - Returns a pass that DelJmp in Cpu0 MachineFunctions</span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">DelJmp</span><span class="p">(</span><span class="n">tm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As above code, except Cpu0DelUselessJMP.cpp, other files changed for register
class DelJmp as a functional pass. As comment of above code, MBB is the current
block and MBBN is the next block. For the last instruction of every MBB, we
check if it is the JMP instruction as well as
its Operand is the next basic block.
By getMBB() in MachineOperand, you can get the MBB address.
For the member function of MachineOperand, please check
include/llvm/CodeGen/MachineOperand.h
Let&#8217;s run Chapter12_1/ with ch12_1.cpp to explain it easier.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch12_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-10:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu
-c ch12_1.cpp -emit-llvm -o ch12_1.bc
118-165-78-10:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm -stats
ch12_1.bc -o ch12_1.cpu0.s
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
                          ... Statistics Collected ...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
 ...
 2 del-jmp        - Number of useless jmp deleted
 ...

  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch12_1.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .frame  <span class="nv">$sp</span>,16,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  bne <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_2</span>
<span class="c"># BB#1:</span>
  ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
<span class="nv">$BB0_2</span>:
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  bne <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_4</span>
  jmp <span class="nv">$BB0_3</span>
<span class="nv">$BB0_4</span>:
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, -1
  slt <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  bne <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_6</span>
  jmp <span class="nv">$BB0_5</span>
<span class="nv">$BB0_3</span>:
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jmp <span class="nv">$BB0_6</span>
<span class="nv">$BB0_5</span>:
  ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$2</span>, -1
  st  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
<span class="nv">$BB0_6</span>:
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  bne <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_8</span>
<span class="c"># BB#7:</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
<span class="nv">$BB0_8</span>:
  ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp1</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-main
</pre></div>
</div>
<p>The terminal display &#8220;Number of useless jmp deleted&#8221; by <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-stats</span></tt> option
because we set the &#8220;STATISTIC(NumDelJmp, &#8220;Number of useless jmp deleted&#8221;)&#8221; in
code. It delete 2 jmp instructions from block &#8220;# BB#0&#8221; and &#8220;$BB0_6&#8221;.
You can check it by <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-enable-cpu0-del-useless-jmp=false</span></tt> option to see
the difference from no optimization version.
If you run with ch8_1_1.cpp, will find 10 jmp instructions are deleted in 100
lines of assembly code, which meaning 10% enhance in speed and code size.</p>
</div>
<div class="section" id="cpu0-optimization-redesign-instruction-sets">
<h2>Cpu0 Optimization: Redesign instruction sets<a class="headerlink" href="#cpu0-optimization-redesign-instruction-sets" title="Permalink to this headline">¶</a></h2>
<p>If you compare the cpu0 and Mips instruction sets, you will find the following,</p>
<ol class="arabic simple">
<li>Mips has <strong>addu</strong> and <strong>add</strong> two different instructions for No Trigger
Exception and Trigger Exception.</li>
<li>Mips use SLT, BEQ and set the status in explicit/general register while Cpu0
use CMP, JEQ and set status in implicit/specific register.</li>
</ol>
<p>According RISC spirits, this section will replace CMP, JEQ with Mips style
instructions and support both Trigger and No Trigger Exception operators.
Mips style BEQ instructions will reduce the number of branch instructions too.
Which means optimization in speed and code size.</p>
<div class="section" id="cpu0-new-instruction-sets-table">
<h3>Cpu0 new instruction sets table<a class="headerlink" href="#cpu0-new-instruction-sets-table" title="Permalink to this headline">¶</a></h3>
<p>Redesign Cpu0 instruction set and remap OP code as follows (OP code
0x00 is reserved for NOP operation in pipeline architecture),</p>
<ul class="simple">
<li>First column F.: meaning Format.</li>
</ul>
<table border="1" class="docutils">
<caption>Cpu0 Instruction Set
      :widths: 1 4 3 11 7 10
      :header-rows: 1</caption>
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>F.</td>
<td>Mnemonic</td>
<td>Opcode</td>
<td>Meaning</td>
<td>Syntax</td>
<td>Operation</td>
</tr>
<tr class="row-even"><td>L</td>
<td>NOP</td>
<td>00</td>
<td>No Operation</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>LD</td>
<td>01</td>
<td>Load word</td>
<td>LD Ra, [Rb+Cx]</td>
<td>Ra &lt;= [Rb+Cx]</td>
</tr>
<tr class="row-even"><td>L</td>
<td>ST</td>
<td>02</td>
<td>Store word</td>
<td>ST Ra, [Rb+Cx]</td>
<td>[Rb+Cx] &lt;= Ra</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>LB</td>
<td>03</td>
<td>Load byte</td>
<td>LB Ra, [Rb+Cx]</td>
<td>Ra &lt;= (byte)[Rb+Cx]</td>
</tr>
<tr class="row-even"><td>L</td>
<td>LBu</td>
<td>04</td>
<td>Load byte unsigned</td>
<td>LBu Ra, [Rb+Cx]</td>
<td>Ra &lt;= (byte)[Rb+Cx]</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>SB</td>
<td>05</td>
<td>Store byte</td>
<td>SB Ra, [Rb+Cx]</td>
<td>[Rb+Cx] &lt;= (byte)Ra</td>
</tr>
<tr class="row-even"><td>A</td>
<td>LH</td>
<td>06</td>
<td>Load half word unsigned</td>
<td>LH Ra, [Rb+Cx]</td>
<td>Ra &lt;= (2bytes)[Rb+Cx]</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>LHu</td>
<td>07</td>
<td>Load half word</td>
<td>LHu Ra, [Rb+Cx]</td>
<td>Ra &lt;= (2bytes)[Rb+Cx]</td>
</tr>
<tr class="row-even"><td>A</td>
<td>SH</td>
<td>08</td>
<td>Store half word</td>
<td>SH Ra, [Rb+Cx]</td>
<td>[Rb+Rc] &lt;= Ra</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>ADDiu</td>
<td>09</td>
<td>Add immediate</td>
<td>ADDiu Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb + Cx)</td>
</tr>
<tr class="row-even"><td>L</td>
<td>ANDi</td>
<td>0C</td>
<td>AND imm</td>
<td>ANDi Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb &amp; Cx)</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>ORi</td>
<td>0D</td>
<td>OR</td>
<td>ORi Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb | Cx)</td>
</tr>
<tr class="row-even"><td>L</td>
<td>XORi</td>
<td>0E</td>
<td>XOR</td>
<td>XORi Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb ^ Cx)</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>LUi</td>
<td>0F</td>
<td>Load upper</td>
<td>LUi Ra, Cx</td>
<td>Ra &lt;= (Cx &lt;&lt; 16)</td>
</tr>
<tr class="row-even"><td>A</td>
<td>ADDu</td>
<td>11</td>
<td>Add unsigned</td>
<td>ADD Ra, Rb, Rc</td>
<td>Ra &lt;= Rb + Rc</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>SUBu</td>
<td>12</td>
<td>Sub unsigned</td>
<td>SUB Ra, Rb, Rc</td>
<td>Ra &lt;= Rb - Rc</td>
</tr>
<tr class="row-even"><td>A</td>
<td>ADD</td>
<td>13</td>
<td>Add</td>
<td>ADD Ra, Rb, Rc</td>
<td>Ra &lt;= Rb + Rc</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>SUB</td>
<td>14</td>
<td>Subtract</td>
<td>SUB Ra, Rb, Rc</td>
<td>Ra &lt;= Rb - Rc</td>
</tr>
<tr class="row-even"><td>A</td>
<td>MUL</td>
<td>17</td>
<td>Multiply</td>
<td>MUL Ra, Rb, Rc</td>
<td>Ra &lt;= Rb * Rc</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>AND</td>
<td>18</td>
<td>Bitwise and</td>
<td>AND Ra, Rb, Rc</td>
<td>Ra &lt;= Rb &amp; Rc</td>
</tr>
<tr class="row-even"><td>A</td>
<td>OR</td>
<td>19</td>
<td>Bitwise or</td>
<td>OR Ra, Rb, Rc</td>
<td>Ra &lt;= Rb | Rc</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>XOR</td>
<td>1A</td>
<td>Bitwise exclusive or</td>
<td>XOR Ra, Rb, Rc</td>
<td>Ra &lt;= Rb ^ Rc</td>
</tr>
<tr class="row-even"><td>A</td>
<td>ROL</td>
<td>1B</td>
<td>Rotate left</td>
<td>ROL Ra, Rb, Cx</td>
<td>Ra &lt;= Rb rol Cx</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>ROR</td>
<td>1C</td>
<td>Rotate right</td>
<td>ROR Ra, Rb, Cx</td>
<td>Ra &lt;= Rb ror Cx</td>
</tr>
<tr class="row-even"><td>A</td>
<td>SRA</td>
<td>1D</td>
<td>Shift right</td>
<td>SRA Ra, Rb, Cx</td>
<td>Ra &lt;= Rb &#8216;&gt;&gt; Cx <a class="footnote-reference" href="#sra-note" id="id1">[1]</a></td>
</tr>
<tr class="row-odd"><td>A</td>
<td>SHL</td>
<td>1E</td>
<td>Shift left</td>
<td>SHL Ra, Rb, Cx</td>
<td>Ra &lt;= Rb &lt;&lt; Cx</td>
</tr>
<tr class="row-even"><td>A</td>
<td>SHR</td>
<td>1F</td>
<td>Shift right</td>
<td>SHR Ra, Rb, Cx</td>
<td>Ra &lt;= Rb &gt;&gt; Cx</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>SRAV</td>
<td>20</td>
<td>Shift right</td>
<td>SRAV Ra, Rb, Rc</td>
<td>Ra &lt;= Rb &#8216;&gt;&gt; Rc <a class="footnote-reference" href="#sra-note" id="id2">[1]</a></td>
</tr>
<tr class="row-even"><td>A</td>
<td>SHLV</td>
<td>21</td>
<td>Shift left</td>
<td>SHLV Ra, Rb, Rc</td>
<td>Ra &lt;= Rb &lt;&lt; Rc</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>SHRV</td>
<td>22</td>
<td>Shift right</td>
<td>SHRV Ra, Rb, Rc</td>
<td>Ra &lt;= Rb &gt;&gt; Rc</td>
</tr>
<tr class="row-even"><td>L</td>
<td>BEQ</td>
<td>30</td>
<td>Jump if equal</td>
<td>BEQ Ra, Rb, Cx</td>
<td>if (Ra==Rb), PC &lt;= PC + Cx</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>BNE</td>
<td>31</td>
<td>Jump if not equal</td>
<td>BNE Ra, Rb, Cx</td>
<td>if (Ra!=Rb), PC &lt;= PC + Cx</td>
</tr>
<tr class="row-even"><td>J</td>
<td>JMP</td>
<td>36</td>
<td>Jump (unconditional)</td>
<td>JMP Cx</td>
<td>PC &lt;= PC + Cx</td>
</tr>
<tr class="row-odd"><td>J</td>
<td>SWI</td>
<td>3A</td>
<td>Software interrupt</td>
<td>SWI Cx</td>
<td>LR &lt;= PC; PC &lt;= Cx</td>
</tr>
<tr class="row-even"><td>J</td>
<td>JSUB</td>
<td>3B</td>
<td>Jump to subroutine</td>
<td>JSUB Cx</td>
<td>LR &lt;= PC; PC &lt;= PC + Cx</td>
</tr>
<tr class="row-odd"><td>J</td>
<td>RET</td>
<td>3C</td>
<td>Return from subroutine</td>
<td>RET LR</td>
<td>PC &lt;= LR</td>
</tr>
<tr class="row-even"><td>J</td>
<td>IRET</td>
<td>3D</td>
<td>Return from interrupt handler</td>
<td>IRET</td>
<td>PC &lt;= LR; INT 0</td>
</tr>
<tr class="row-odd"><td>J</td>
<td>JALR</td>
<td>3E</td>
<td>Jump to subroutine</td>
<td>JR Rb</td>
<td>LR &lt;= PC; PC &lt;= Rb</td>
</tr>
<tr class="row-even"><td>L</td>
<td>SLTi</td>
<td>26</td>
<td>Set less Then</td>
<td>SLTi Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb &lt; Cx)</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>SLTiu</td>
<td>27</td>
<td>SLTi unsigned</td>
<td>SLTiu Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb &lt; Cx)</td>
</tr>
<tr class="row-even"><td>A</td>
<td>SLT</td>
<td>28</td>
<td>Set less Then</td>
<td>SLT Ra, Rb, Rc</td>
<td>Ra &lt;= (Rb &lt; Rc)</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>SLTu</td>
<td>29</td>
<td>SLT unsigned</td>
<td>SLTu Ra, Rb, Rc</td>
<td>Ra &lt;= (Rb &lt; Rc)</td>
</tr>
<tr class="row-even"><td>L</td>
<td>MULT</td>
<td>41</td>
<td>Multiply for 64 bits result</td>
<td>MULT Ra, Rb</td>
<td>(HI,LO) &lt;= MULT(Ra,Rb)</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>MULTU</td>
<td>42</td>
<td>MULT for unsigned 64 bits</td>
<td>MULTU Ra, Rb</td>
<td>(HI,LO) &lt;= MULTU(Ra,Rb)</td>
</tr>
<tr class="row-even"><td>L</td>
<td>DIV</td>
<td>43</td>
<td>Divide</td>
<td>DIV Ra, Rb</td>
<td>HI&lt;=Ra%Rb, LO&lt;=Ra/Rb</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>DIVU</td>
<td>44</td>
<td>Divide</td>
<td>DIV Ra, Rb</td>
<td>HI&lt;=Ra%Rb, LO&lt;=Ra/Rb</td>
</tr>
<tr class="row-even"><td>L</td>
<td>MFHI</td>
<td>46</td>
<td>Move HI to GPR</td>
<td>MFHI Ra</td>
<td>Ra &lt;= HI</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>MFLO</td>
<td>47</td>
<td>Move LO to GPR</td>
<td>MFLO Ra</td>
<td>Ra &lt;= LO</td>
</tr>
<tr class="row-even"><td>L</td>
<td>MTHI</td>
<td>48</td>
<td>Move GPR to HI</td>
<td>MTHI Ra</td>
<td>HI &lt;= Ra</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>MTLO</td>
<td>49</td>
<td>Move GPR to LO</td>
<td>MTLO Ra</td>
<td>LO &lt;= Ra</td>
</tr>
</tbody>
</table>
<p>As above, the OPu, such as ADDu is for unsigned integer or No Trigger
Exception. The LUi for example, &#8220;LUi $2, 0x7000&#8221;, load 0x700 to high 16 bits
of $2 and fill the low 16 bits of $2 to 0x0000.</p>
</div>
<div class="section" id="cpu0-code-changes">
<h3>Cpu0 code changes<a class="headerlink" href="#cpu0-code-changes" title="Permalink to this headline">¶</a></h3>
<p>Chapter12_2/ include the changes for new instruction sets as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0AsmParser.cpp</span>
<span class="p">...</span>
<span class="kt">int</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">matchRegisterName</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;t0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">T0</span><span class="p">)</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Decoder tables for Cpu0 register</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">CPURegsTable</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="c1">// Change SW to T0 which is a caller saved</span>
  <span class="n">Cpu0</span><span class="o">::</span><span class="n">T0</span><span class="p">,</span> <span class="p">...</span>
<span class="p">};</span>

<span class="c1">// DecodeCMPInstruction() function is removed since No CMP instruction.</span>
<span class="p">...</span>

<span class="c1">// Change DecodeBranchTarget() to following for 16 bit offset</span>
<span class="k">static</span> <span class="n">DecodeStatus</span> <span class="n">DecodeBranchTarget</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span>
                                       <span class="kt">unsigned</span> <span class="n">Insn</span><span class="p">,</span>
                                       <span class="n">uint64_t</span> <span class="n">Address</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Decoder</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">BranchOffset</span> <span class="o">=</span> <span class="n">fieldFromInstruction</span><span class="p">(</span><span class="n">Insn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">BranchOffset</span> <span class="o">&gt;</span> <span class="mh">0x8fff</span><span class="p">)</span>
      <span class="n">BranchOffset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="mh">0x10000</span> <span class="o">-</span> <span class="n">BranchOffset</span><span class="p">);</span>
  <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">BranchOffset</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">MCDisassembler</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">unsigned</span> <span class="n">adjustFixupValue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Kind</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Add/subtract and shift</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_PC16:</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_PC24:</span>
    <span class="c1">// So far we are only using this type for branches.</span>
    <span class="c1">// For branches we start 1 instruction after the branch</span>
    <span class="c1">// so the displacement will be one instruction size less.</span>
    <span class="n">Value</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="k">const</span> <span class="n">MCFixupKindInfo</span> <span class="o">&amp;</span><span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">MCFixupKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">static</span> <span class="n">MCFixupKindInfo</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">NumTargetFixupKinds</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// This table *must* be in same the order of fixup_* kinds in</span>
      <span class="c1">// Cpu0FixupKinds.h.</span>
      <span class="c1">//</span>
      <span class="c1">// name                    offset  bits  flags</span>
      <span class="p">...</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_PC16&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>  <span class="n">MCFixupKindInfo</span><span class="o">::</span><span class="n">FKF_IsPCRel</span> <span class="p">},</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/MCTargetDesc/Cpu0BaseInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kr">inline</span> <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">RegEnum</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">T0:</span>
  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/MCTargetDesc/Cpu0FixupKinds.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// PC relative branch fixup resulting in - R_CPU0_PC16.</span>
  <span class="c1">// cpu0 PC16, e.g. beq</span>
  <span class="n">fixup_Cpu0_PC16</span><span class="p">,</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getBranchTargetOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                       <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">Fixups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MCFixup</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span>
                                   <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_PC16</span><span class="p">)));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getJumpTargetOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JMP</span><span class="p">)</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0InstrInfo::copyPhysReg()</span>
<span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span>
<span class="n">copyPhysReg</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
            <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">KillSrc</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">DestReg</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Copy to CPU Reg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MFHI</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MFLO</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Copy from CPU Reg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MTHI</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MTLO</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Cannot copy registers&quot;</span><span class="p">);</span>

  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">DestReg</span><span class="p">,</span> <span class="n">RegState</span><span class="o">::</span><span class="n">Define</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ZeroReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZeroReg</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">,</span> <span class="n">getKillRegState</span><span class="p">(</span><span class="n">KillSrc</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def jmptarget    : Operand&lt;OtherVT&gt; {
  let EncoderMethod = "getJumpTargetOpValue";
  let OperandType = "OPERAND_PCREL";
  let DecoderMethod = "DecodeJumpRelativeTarget";
}
...
// Immediate can be loaded with LUi (32-bit int with lower 16-bit cleared).
def immLow16Zero : PatLeaf&lt;(imm), [{
  int64_t Val = N-&gt;getSExtValue();
  return isInt&lt;32&gt;(Val) &amp;&amp; !(Val &amp; 0xffff);
}]&gt;;
...
class ArithOverflowR&lt;bits&lt;8&gt; op, string instr_asm,
                    InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"), [], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;
}
// Conditional Branch
class CBranch&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op, RegisterClass RC&gt;:
  FL&lt;op, (outs), (ins RC:$ra, RC:$rb, brtarget:$imm16),
             !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
             [(brcond (i32 (cond_op RC:$ra, RC:$rb)), bb:$imm16)], IIBranch&gt; {
  let isBranch = 1;
  let isTerminator = 1;
  let hasDelaySlot = 1;
  let Defs = [AT];
}
...
// SetCC
class SetCC_R&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op,
              RegisterClass RC&gt;:
  FA&lt;op, (outs CPURegs:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
     [(set CPURegs:$ra, (cond_op RC:$rb, RC:$rc))],
     IIAlu&gt; {
  let shamt = 0;
}

class SetCC_I&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op, Operand Od,
              PatLeaf imm_type, RegisterClass RC&gt;:
  FL&lt;op, (outs CPURegs:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
     [(set CPURegs:$ra, (cond_op RC:$rb, imm_type:$imm16))],
     IIAlu&gt;;
// Unconditional branch, such as JMP
class UncondBranch&lt;bits&lt;8&gt; op, string instr_asm&gt;:
  FJ&lt;op, (outs), (ins jmptarget:$addr),
             !strconcat(instr_asm, "\t$addr"), [(br bb:$addr)], IIBranch&gt; {
  let isBranch = 1;
  let isTerminator = 1;
  let isBarrier = 1;
  let hasDelaySlot = 0;
}
...
def SLTi    : SetCC_I&lt;0x26, "slti", setlt, simm16, immSExt16, CPURegs&gt;;
def SLTiu   : SetCC_I&lt;0x27, "sltiu", setult, simm16, immSExt16, CPURegs&gt;;
def SLT     : SetCC_R&lt;0x28, "slt", setlt, CPURegs&gt;;
def SLTu    : SetCC_R&lt;0x29, "sltu", setult, CPURegs&gt;;

/// Jump and Branch Instructions
def BEQ     : CBranch&lt;0x30, "beq", seteq, CPURegs&gt;;
def BNE     : CBranch&lt;0x31, "bne", setne, CPURegs&gt;;

// brcond patterns
multiclass BrcondPats&lt;RegisterClass RC, Instruction BEQOp, Instruction BNEOp,
                      Instruction SLTOp, Instruction SLTuOp, Instruction SLTiOp,
                      Instruction SLTiuOp, Register ZEROReg&gt; {
def : Pat&lt;(brcond (i32 (setne RC:$lhs, 0)), bb:$dst),
              (BNEOp RC:$lhs, ZEROReg, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (seteq RC:$lhs, 0)), bb:$dst),
              (BEQOp RC:$lhs, ZEROReg, bb:$dst)&gt;;

def : Pat&lt;(brcond (i32 (setge RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTOp RC:$lhs, RC:$rhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setuge RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTuOp RC:$lhs, RC:$rhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setge RC:$lhs, immSExt16:$rhs)), bb:$dst),
              (BEQ (SLTiOp RC:$lhs, immSExt16:$rhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setuge RC:$lhs, immSExt16:$rhs)), bb:$dst),
              (BEQ (SLTiuOp RC:$lhs, immSExt16:$rhs), ZERO, bb:$dst)&gt;;

def : Pat&lt;(brcond (i32 (setle RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTOp RC:$rhs, RC:$lhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setule RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTuOp RC:$rhs, RC:$lhs), ZERO, bb:$dst)&gt;;

def : Pat&lt;(brcond RC:$cond, bb:$dst),
              (BNEOp RC:$cond, ZEROReg, bb:$dst)&gt;;
}

defm : BrcondPats&lt;CPURegs, BEQ, BNE, SLT, SLTu, SLTi, SLTiu, ZERO&gt;;


// setcc patterns
multiclass SeteqPats&lt;RegisterClass RC, Instruction SLTiuOp, Instruction XOROp,
                     Instruction SLTuOp, Register ZEROReg&gt; {
// a == b
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
                (SLTiuOp (XOROp RC:$lhs, RC:$rhs), 1)&gt;;
// a != b
  def : Pat&lt;(setne RC:$lhs, RC:$rhs),
                (SLTuOp ZEROReg, (XOROp RC:$lhs, RC:$rhs))&gt;;
}

// a &lt;= b
multiclass SetlePats&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setle RC:$lhs, RC:$rhs),
// a &lt;= b is equal to (XORi (b &lt; a), 1)
                (XORi (SLTOp RC:$rhs, RC:$lhs), 1)&gt;;
  def : Pat&lt;(setule RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$rhs, RC:$lhs), 1)&gt;;
}

// a &gt; b
multiclass SetgtPats&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setgt RC:$lhs, RC:$rhs),
// a &gt; b is equal to b &lt; a is equal to setlt(b, a)
                (SLTOp RC:$rhs, RC:$lhs)&gt;;
  def : Pat&lt;(setugt RC:$lhs, RC:$rhs),
                (SLTuOp RC:$rhs, RC:$lhs)&gt;;
}

// a &gt;= b
multiclass SetgePats&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, RC:$rhs),
// a &gt;= b is equal to b &lt;= a
                (XORi (SLTOp RC:$lhs, RC:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$lhs, RC:$rhs), 1)&gt;;
}

multiclass SetgeImmPats&lt;RegisterClass RC, Instruction SLTiOp,
                        Instruction SLTiuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiuOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
}

defm : SeteqPats&lt;CPURegs, SLTiu, XOR, SLTu, ZERO&gt;;
defm : SetlePats&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgtPats&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgePats&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgeImmPats&lt;CPURegs, SLTi, SLTiu&gt;;</pre>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">SUBE:</span>
  <span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">ADDE:</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">SDNode</span> <span class="o">*</span><span class="n">StatusWord</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CMP</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">Constant1</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
    <span class="n">SDNode</span> <span class="o">*</span><span class="n">Carry</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ANDi</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span>
                                           <span class="n">SDValue</span><span class="p">(</span><span class="n">StatusWord</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">Constant1</span><span class="p">);</span>
    <span class="p">...</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter12_2/Cpu0RegisterInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span> <span class="n">in</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">def</span> <span class="n">T0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span> <span class="mi">12</span><span class="p">,</span> <span class="s">&quot;t0&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="n">def</span> <span class="n">CPURegs</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
  <span class="n">T0</span><span class="p">,</span>
  <span class="c1">// Reserved</span>
  <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">PC</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Remove SR RegisterClass since no SW in General register</span>
<span class="c1">// Status Registers</span>
<span class="cm">/* def SR   : RegisterClass&lt;&quot;Cpu0&quot;, [i32], 32, (add SW)&gt;;*/</span>
</pre></div>
</div>
<p>As modified from above, it remove the CMP instruction, SW register and
related code from Chapter12_1/, and change from JEQ 24bits offset to BEQ 16 bits
offset.</p>
</div>
<div class="section" id="cpu0-verilog-language-changes">
<h3>Cpu0 Verilog language changes<a class="headerlink" href="#cpu0-verilog-language-changes" title="Permalink to this headline">¶</a></h3>
<p class="rubric">LLVMBackendTutorialExampleCode/cpu0_verilog/redesign/cpu0s.v</p>
<div class="highlight-c++"><pre>//`define TRACE

`define MEMSIZE 'h80000
`define MEMEMPTY 8'hFF
`define NULL     8'h00
`define IOADDR  'h80000

// Operand width
`define INT32 2'b11     // 32 bits
`define INT24 2'b10     // 24 bits
`define INT16 2'b01     // 16 bits
`define BYTE  2'b00     // 8  bits

`define EXE 3'b000
`define RESET 3'b001
`define ABORT 3'b010
`define IRQ 3'b011
`define ERROR 3'b100

// Reference web: http://ccckmit.wikidot.com/ocs:cpu0
module cpu0(input clock, reset, input [2:0] itype, output reg [2:0] tick, 
            output reg [31:0] ir, pc, mar, mdr, inout [31:0] dbus, 
            output reg m_en, m_rw, output reg [1:0] m_size);
  reg signed [31:0] R [0:15], SW; 
  // HI, LO: High and Low part of 64 bit result
  // SW: Status Word
  reg [7:0] op;
  reg [3:0] a, b, c;
  reg [4:0] c5;
  reg signed [31:0] c12, c16, uc16, c24, Ra, Rb, Rc, pc0; // pc0 : instruction pc
  reg [31:0] URa, URb, URc, HI, LO;

  // register name
  `define PC   R[15]   // Program Counter
  `define LR   R[14]   // Link Register
  `define SP   R[13]   // Stack Pointer
  // SW Flage
  `define C    SW[29] // Carry
  `define V    SW[28] // Overflow
  `define MODE SW[25:23] // itype
  `define I2   SW[16] // Hardware Interrupt 1, IO1 interrupt, status, 1: in interrupt
  `define I1   SW[15] // Hardware Interrupt 0, timer interrupt, status, 1: in interrupt
  `define I0   SW[14] // Software interrupt, status, 1: in interrupt
  `define I    SW[13] // Interrupt, 1: in interrupt
  `define I2E  SW[8]  // Hardware Interrupt 1, IO1 interrupt, Enable
  `define I1E  SW[7]  // Hardware Interrupt 0, timer interrupt, Enable
  `define I0E  SW[6]  // Software Interrupt Enable
  `define IE   SW[5]  // Interrupt Enable
  `define M    SW[4]  // Mode bit
  `define Z    SW[1] // Zero
  `define N    SW[0] // Negative flag
  // Instruction Opcode 
  parameter [7:0] LD=8'h01,ST=8'h02,LB=8'h03,LBu=8'h04,SB=8'h05,LH=8'h06,
  LHu=8'h07,SH=8'h08,ADDiu=8'h09,ANDi=8'h0C,ORi=8'h0D,
  XORi=8'h0E,LUi=8'h0F,
  ADDu=8'h11,SUBu=8'h12,ADD=8'h13,SUB=8'h14,MUL=8'h17,
  AND=8'h18,OR=8'h19,XOR=8'h1A,
  ROL=8'h1B,ROR=8'h1C,SRA=8'h1D,SHL=8'h1E,SHR=8'h1F,
  SRAV=8'h20,SHLV=8'h21,SHRV=8'h22,
  SLTi=8'h26,SLTiu=8'h27, SLT=8'h28,SLTu=8'h29,
  BEQ=8'h30,BNE=8'h31,
  JMP=8'h36,
  SWI=8'h3A,JSUB=8'h3B,RET=8'h3C,IRET=8'h3D,JALR=8'h3E,
  MULT=8'h41,MULTu=8'h42,DIV=8'h43,DIVu=8'h44,
  MFHI=8'h46,MFLO=8'h47,MTHI=8'h48,MTLO=8'h49;

  reg [0:0] inInt = 0;
  reg [2:0] state, next_state; 
  parameter Reset=3'h0, Fetch=3'h1, Decode=3'h2, Execute=3'h3, WriteBack=3'h4;
  integer i;

  task memReadStart(input [31:0] addr, input [1:0] size); begin // Read Memory Word
    mar = addr;     // read(m[addr])
    m_rw = 1;     // Access Mode: read 
    m_en = 1;     // Enable read
    m_size = size;
  end endtask

  task memReadEnd(output [31:0] data); begin // Read Memory Finish, get data
    mdr = dbus; // get momory, dbus = m[addr]
    data = mdr; // return to data
    m_en = 0; // read complete
  end endtask

  // Write memory -- addr: address to write, data: date to write
  task memWriteStart(input [31:0] addr, input [31:0] data, input [1:0] size); begin 
    mar = addr;    // write(m[addr], data)
    mdr = data;
    m_rw = 0;    // access mode: write
    m_en = 1;     // Enable write
    m_size  = size;
  end endtask

  task memWriteEnd; begin // Write Memory Finish
    m_en = 0; // write complete
  end endtask

  task regSet(input [3:0] i, input [31:0] data); begin
    if (i != 0) R[i] = data;
  end endtask

  task regHILOSet(input [31:0] data1, input [31:0] data2); begin
    HI = data1;
    LO = data2;
  end endtask

  task outw(input [31:0] data); begin
    if (data[7:0] != 8'h00) begin
      $write("%c", data[7:0]);
      if (data[15:8] != 8'h00) 
        $write("%c", data[15:8]);
      if (data[23:16] != 8'h00) 
        $write("%c", data[23:16]);
      if (data[31:24] != 8'h00) 
        $write("%c", data[31:24]);
    end
  end endtask

  task outc(input [7:0] data); begin
      $write("%c", data[7:0]);
  end endtask

  task taskInterrupt(input [2:0] iMode); begin
  if (inInt == 0) begin
    case (iMode)
      `RESET: begin 
        `PC = 0; tick = 0; R[0] = 0; SW = 0; `LR = -1;
        `IE = 0; `I0E = 0; `I1E = 0; `I2E = 0; `I = 0; `I0 = 0; `I1 = 0; `I2 = 0;
      end
      `ABORT: begin `LR = `PC; `PC = 4; end
      `IRQ:   begin `LR = `PC; `PC = 8; end
      `ERROR: begin `LR = `PC; `PC = 12; end
    endcase
    $display("taskInterrupt(%3b)", iMode);
    inInt = 1;
  end
  end endtask

  task taskExecute; begin
    m_en = 0;
    tick = tick+1;
    case (state)
    Fetch: begin  // Tick 1 : instruction fetch, throw PC to address bus, 
                  // memory.read(m[PC])
      memReadStart(`PC, `INT32);
      pc0  = `PC;
      `PC = `PC+4;
      next_state = Decode;
    end
    Decode: begin  // Tick 2 : instruction decode, ir = m[PC]
      memReadEnd(ir); // IR = dbus = m[PC]
      {op,a,b,c} = ir[31:12];
      c24 = $signed(ir[23:0]);
      c16 = $signed(ir[15:0]);
      uc16 = ir[15:0];
      c12 = $signed(ir[11:0]);
      c5  = ir[4:0];
      Ra = R[a];
      Rb = R[b];
      Rc = R[c];
      URa = R[a];
      URb = R[b];
      URc = R[c];
      next_state = Execute;
    end
    Execute: begin // Tick 3 : instruction execution
      case (op)
      // load and store instructions
      LD:    memReadStart(Rb+c16, `INT32);      // LD Ra,[Rb+Cx]; Ra&lt;=[Rb+Cx]
      ST:    memWriteStart(Rb+c16, Ra, `INT32); // ST Ra,[Rb+Cx]; Ra=&gt;[Rb+Cx]
      LB:    memReadStart(Rb+c16, `BYTE);     // LB Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      LBu:   memReadStart(Rb+c16, `BYTE);     // LBu Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      SB:    memWriteStart(Rb+c16, Ra, `BYTE);// SB Ra,[Rb+Cx]; Ra=&gt;(byte)[Rb+Cx]
      LH:    memReadStart(Rb+c16, `INT16);     // LH Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      LHu:   memReadStart(Rb+c16, `INT16);     // LHu Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      SH:    memWriteStart(Rb+c16, Ra, `INT16);// SH Ra,[Rb+Cx]; Ra=&gt;(2bytes)[Rb+Cx]
      // Mathematic 
      ADDiu: R[a] = Rb+c16;                   // ADDiu Ra, Rb+Cx; Ra&lt;=Rb+Cx
      ADDu:  regSet(a, Rb+Rc);               // ADDu Ra,Rb,Rc; Ra&lt;=Rb+Rc
      ADD:   begin regSet(a, Rb+Rc); if (a &lt; Rb) `V = 1; else `V =0; end
                                             // ADD Ra,Rb,Rc; Ra&lt;=Rb+Rc
      SUBu:  regSet(a, Rb-Rc);               // SUBu Ra,Rb,Rc; Ra&lt;=Rb-Rc
      SUB:   begin regSet(a, Rb-Rc); if (Rb &lt; 0 &amp;&amp; Rc &gt; 0 &amp;&amp; a &gt;= 0) 
             `V = 1; else `V =0; end         // SUB Ra,Rb,Rc; Ra&lt;=Rb-Rc
      MUL:   regSet(a, Rb*Rc);               // MUL Ra,Rb,Rc;     Ra&lt;=Rb*Rc
      DIVu:  regHILOSet(URa%URb, URa/URb);   // DIVu URa,URb; HI&lt;=URa%URb; LO&lt;=URa/URb
                                             // without exception overflow
      DIV:   begin regHILOSet(Ra%Rb, Ra/Rb); 
             if ((Ra &lt; 0 &amp;&amp; Rb &lt; 0) || (Ra == 0)) `V = 1; 
             else `V =0; end  // DIV Ra,Rb; HI&lt;=Ra%Rb; LO&lt;=Ra/Rb; With overflow
      AND:   regSet(a, Rb&amp;Rc);               // AND Ra,Rb,Rc; Ra&lt;=(Rb and Rc)
      ANDi:  regSet(a, Rb&amp;uc16);             // ANDi Ra,Rb,c16; Ra&lt;=(Rb and c16)
      OR:    regSet(a, Rb|Rc);               // OR Ra,Rb,Rc; Ra&lt;=(Rb or Rc)
      ORi:   regSet(a, Rb|uc16);             // ORi Ra,Rb,c16; Ra&lt;=(Rb or c16)
      XOR:   regSet(a, Rb^Rc);               // XOR Ra,Rb,Rc; Ra&lt;=(Rb xor Rc)
      XORi:  regSet(a, Rb^uc16);             // XORi Ra,Rb,c16; Ra&lt;=(Rb xor c16)
      LUi:   regSet(a, uc16&lt;&lt;16);
      SHL:   regSet(a, Rb&lt;&lt;c5);     // Shift Left; SHL Ra,Rb,Cx; Ra&lt;=(Rb &lt;&lt; Cx)
      SRA:   regSet(a, (Rb&amp;'h80000000)|(Rb&gt;&gt;c5)); 
                                    // Shift Right with signed bit fill;
                                    // SHR Ra,Rb,Cx; Ra&lt;=(Rb&amp;0x80000000)|(Rb&gt;&gt;Cx)
      SHR:   regSet(a, Rb&gt;&gt;c5);     // Shift Right with 0 fill; 
                                    // SHR Ra,Rb,Cx; Ra&lt;=(Rb &gt;&gt; Cx)
      SHLV:  regSet(a, Rb&lt;&lt;Rc);     // Shift Left; SHLV Ra,Rb,Rc; Ra&lt;=(Rb &lt;&lt; Rc)
      SRAV:  regSet(a, (Rb&amp;'h80000000)|(Rb&gt;&gt;Rc)); 
                                    // Shift Right with signed bit fill;
                                    // SHRV Ra,Rb,Rc; Ra&lt;=(Rb&amp;0x80000000)|(Rb&gt;&gt;Rc)
      SHRV:  regSet(a, Rb&gt;&gt;Rc);     // Shift Right with 0 fill; 
                                    // SHRV Ra,Rb,Rc; Ra&lt;=(Rb &gt;&gt; Rc)
      ROL:   regSet(a, (Rb&lt;&lt;c5)|(Rb&gt;&gt;(32-c5)));     // Rotate Left;
      ROR:   regSet(a, (Rb&gt;&gt;c5)|(Rb&lt;&lt;(32-c5)));     // Rotate Right;
      // set
      SLT:   if (Rb &lt; Rc) R[a]=1; else R[a]=0;
      SLTu:  if (Rb &lt; Rc) R[a]=1; else R[a]=0;
      SLTi:  if (Rb &lt; c16) R[a]=1; else R[a]=0;
      SLTiu: if (Rb &lt; c16) R[a]=1; else R[a]=0;
      // Branch Instructions
      BEQ:   if (Ra==Rb) `PC=`PC+c16; 
      BNE:   if (Ra!=Rb) `PC=`PC+c16;
      MFLO:  regSet(a, LO);         // MFLO Ra; Ra&lt;=LO
      MFHI:  regSet(a, HI);         // MFHI Ra; Ra&lt;=HI
      MTLO:  LO = Ra;               // MTLO Ra; LO&lt;=Ra
      MTHI:  HI = Ra;               // MTHI Ra; HI&lt;=Ra
      MULT:  {HI, LO}=Ra*Rb;        // MULT Ra,Rb; HI&lt;=((Ra*Rb)&gt;&gt;32); 
                                    // LO&lt;=((Ra*Rb) and 0x00000000ffffffff);
                                    // with exception overflow
      MULTu: {HI, LO}=URa*URb;      // MULT URa,URb; HI&lt;=((URa*URb)&gt;&gt;32); 
                                    // LO&lt;=((URa*URb) and 0x00000000ffffffff);
                                    // without exception overflow
      // Jump Instructions
      JMP:   `PC = `PC+c24;                  // JMP Cx; PC &lt;= PC+Cx
      SWI:   begin 
        `LR=`PC;`PC= c24; `I0 = 1'b1; `I = 1'b1;
      end // Software Interrupt; SWI Cx; LR &lt;= PC; PC &lt;= Cx; INT&lt;=1
      JSUB:  begin `LR=`PC;`PC=`PC + c24; end // JSUB Cx; LR&lt;=PC; PC&lt;=PC+Cx
      JALR:  begin `LR=`PC;`PC=Ra; end // JALR Ra,Rb; Ra&lt;=PC; PC&lt;=Rb
      RET:   begin `PC=`LR; end               // RET; PC &lt;= LR
      IRET:  begin 
        `PC=Ra;`I = 1'b0; `MODE = `EXE;
      end // Interrupt Return; IRET; PC &lt;= LR; INT&lt;=0
      default : 
        $display("%4dns %8x : OP code %8x not support", $stime, pc0, op);
      endcase
      next_state = WriteBack;
    end
    WriteBack: begin // Read/Write finish, close memory
      case (op)
        LD, LB, LBu, LH, LHu  : memReadEnd(R[a]); 
                                          //read memory complete
        ST, SB, SH  : memWriteEnd(); 
                                          // write memory complete
      endcase
      case (op)
      `ifdef TRACE
      MULT, MULTu, DIV, DIVu, MTHI, MTLO :
        $display("%4dns %8x : %8x HI=%8x LO=%8x SW=%8x", $stime, pc0, ir, HI, 
        LO, SW);
      `endif
      ST : begin
      `ifdef TRACE
        $display("%4dns %8x : %8x m[%-04d+%-04d]=%-d  SW=%8x", $stime, pc0, ir, 
        R[b], c16, R[a], SW);
      `endif
        if (R[b]+c16 == `IOADDR) begin
          outw(R[a]);
        end
      end
      SB : begin
      `ifdef TRACE
        $display("%4dns %8x : %8x m[%-04d+%-04d]=%c  SW=%8x", $stime, pc0, ir, 
        R[b], c16, R[a][7:0], SW);
      `endif
        if (R[b]+c16 == `IOADDR) begin
          outc(R[a][7:0]);
        end
      end
      `ifdef TRACE
      default : 
        $display("%4dns %8x : %8x R[%02d]=%-8x=%-d SW=%8x", $stime, pc0, ir, a, 
        R[a], R[a], SW);
      `endif
      endcase
      if (op==RET &amp;&amp; `PC &lt; 0) begin
        $display("RET to PC &lt; 0, finished!");
        $finish;
      end
      next_state = Fetch;
    end
    endcase
  end endtask

  always @(posedge clock) begin
    if (inInt == 0 &amp;&amp; itype == `RESET) begin
      taskInterrupt(`RESET);
      `MODE = `RESET;
      state = Fetch;
    end else if (inInt == 0 &amp;&amp; (state == Fetch) &amp;&amp; (`IE &amp;&amp; `I) &amp;&amp; ((`I0E &amp;&amp; `I0) || (`I1E &amp;&amp; `I1) || (`I2E &amp;&amp; `I2)) ) begin
      `MODE = `IRQ;
      taskInterrupt(`IRQ);
      state = Fetch;
    end else begin
      taskExecute();
      state = next_state;
    end
    pc = `PC;
  end
endmodule

module memory0(input clock, reset, en, rw, input [1:0] m_size, 
                input [31:0] abus, dbus_in, output [31:0] dbus_out);
  reg [7:0] m [0:`MEMSIZE-1];
  reg [31:0] data;

  integer i;
  initial begin
  // erase memory
    for (i=0; i &lt; `MEMSIZE; i=i+1) begin
       m[i] = `MEMEMPTY;
    end
  // display memory contents
    $readmemh("cpu0s.hex", m);
    `ifdef TRACE
    for (i=0; i &lt; `MEMSIZE &amp;&amp; (m[i] != `MEMEMPTY || m[i+1] != `MEMEMPTY || m[i+2] != `MEMEMPTY || m[i+3] != `MEMEMPTY); i=i+4) begin
       $display("%8x: %8x", i, {m[i], m[i+1], m[i+2], m[i+3]});
    end
    `endif
  end

  always @(clock or abus or en or rw or dbus_in) 
  begin
    if (abus &gt;=0 &amp;&amp; abus &lt;= `MEMSIZE-4) begin
      if (en == 1 &amp;&amp; rw == 0) begin // r_w==0:write
        data = dbus_in;
        case (m_size)
        `BYTE:  {m[abus]} = dbus_in[7:0];
        `INT16: {m[abus], m[abus+1] } = dbus_in[15:0];
        `INT24: {m[abus], m[abus+1], m[abus+2]} = dbus_in[24:0];
        `INT32: {m[abus], m[abus+1], m[abus+2], m[abus+3]} = dbus_in;
        endcase
      end else if (en == 1 &amp;&amp; rw == 1) begin// r_w==1:read
        case (m_size)
        `BYTE:  data = {8'h00  , 8'h00,   8'h00,   m[abus]      };
        `INT16: data = {8'h00  , 8'h00,   m[abus], m[abus+1]    };
        `INT24: data = {8'h00  , m[abus], m[abus+1], m[abus+2]  };
        `INT32: data = {m[abus], m[abus+1], m[abus+2], m[abus+3]};
        endcase
      end else
        data = 32'hZZZZZZZZ;
    end else
      data = 32'hZZZZZZZZ;
  end
  assign dbus_out = data;
endmodule

module main;
  reg clock;
  reg [2:0] itype;
  wire [2:0] tick;
  wire [31:0] pc, ir, mar, mdr, dbus;
  wire m_en, m_rw;
  wire [1:0] m_size;

  cpu0 cpu(.clock(clock), .itype(itype), .pc(pc), .tick(tick), .ir(ir),
  .mar(mar), .mdr(mdr), .dbus(dbus), .m_en(m_en), .m_rw(m_rw), .m_size(m_size));

  memory0 mem(.clock(clock), .reset(reset), .en(m_en), .rw(m_rw), .m_size(m_size), 
  .abus(mar), .dbus_in(mdr), .dbus_out(dbus));

  initial
  begin
    clock = 0;
    itype = `RESET;
    #3000000 $finish;
  end

  always #10 clock=clock+1;

endmodule
</pre>
</div>
</div>
<div class="section" id="run-the-redesigned-cpu0">
<h3>Run the redesigned Cpu0<a class="headerlink" href="#run-the-redesigned-cpu0" title="Permalink to this headline">¶</a></h3>
<p>Run Chapter12_2/ with ch_run_backend.cpp to get result as below.
It match the expect value as comment in ch_run_backend.cpp.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch_run_backend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;boot.cpp&quot;</span>

<span class="cp">#include &quot;print.h&quot;</span>

<span class="kt">int</span> <span class="n">test_math</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">test_div</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">test_local_pointer</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">test_andorxornot</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">test_setxx</span><span class="p">();</span>
<span class="kt">bool</span> <span class="n">test_load_bool</span><span class="p">();</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="n">test_longlong</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">test_control1</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_math</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 74</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_div</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 253</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_local_pointer</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 3</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">test_load_bool</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_andorxornot</span><span class="p">();</span> <span class="c1">// a = 14</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_setxx</span><span class="p">();</span> <span class="c1">// a = 3</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">test_longlong</span><span class="p">();</span> <span class="c1">// 0x800000002</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span> <span class="c1">// 393307</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 16777222</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_control1</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>	<span class="c1">// a = 51</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">);</span> <span class="c1">// test mod % (mult) from itoa.cpp</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="o">-</span><span class="mi">2147483648</span><span class="p">);</span> <span class="c1">// test mod % (multu) from itoa.cpp</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>    <span class="c1">// a = 15</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;print.cpp&quot;</span>

<span class="kt">void</span> <span class="n">print1_integer</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $at, 8($sp)&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;st $at, 28672($0)&quot;</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">// For instruction IO</span>
<span class="c">void print2_integer(int x)</span>
<span class="c">{</span>
<span class="c">  asm(&quot;ld $at, 8($sp)&quot;);</span>
<span class="c">  asm(&quot;outw $tat&quot;);</span>
<span class="c">  return;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="kt">bool</span> <span class="n">test_load_bool</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>
<span class="kt">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cp">#include &quot;ch4_1.cpp&quot;</span>
<span class="cp">#include &quot;ch4_3.cpp&quot;</span>
<span class="cp">#include &quot;ch4_5.cpp&quot;</span>
<span class="cp">#include &quot;ch7_1.cpp&quot;</span>
<span class="cp">#include &quot;ch7_4.cpp&quot;</span>
<span class="cp">#include &quot;ch8_1_1.cpp&quot;</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>obj -stats
ch_run_backend.bc -o ch_run_backend.cpu0.o
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
                          ... Statistics Collected ...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
  ...
   5 del-jmp     - Number of useless jmp deleted
  ...

118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llvm-objdump -d ch_run_backend.cpu0.o | tail -n +6| awk <span class="s1">&#39;{print &quot;/* &quot; $1</span>
<span class="s1">&quot; */\t&quot; $2 &quot; &quot; $3 &quot; &quot; $4 &quot; &quot; $5 &quot;\t/* &quot; $6&quot;\t&quot; $7&quot; &quot; $8&quot; &quot; $9&quot; &quot; $10 &quot;\t*/&quot;}&#39;</span> &gt;
../cpu0_verilog/redesign/cpu0s.hex

JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../cpu0_verilog/redesign/
JonathantekiiMac:redesign Jonathan<span class="nv">$ </span>iverilog -o cpu0s cpu0s.v
JonathantekiiMac:redesign Jonathan<span class="nv">$ </span>./cpu0s
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
74
253
3
1
14
3
393307
16777222
51
2147483647
-2147483648
15
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>Run with ch8_1_1.cpp, it reduce some branch from pair instructions &#8220;CMP, JXX&#8221;
to 1 single instruction ether is BEQ or BNE, as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch8_1_1.bc -o
ch8_1_1.cpu0.s
118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>cat ch8_1_1.cpu0.s
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;ch8_1_1.bc&quot;</span>
        .text
        .globl        _Z13test_control1v
        .align        2
        .type _Z13test_control1v,@function
        .ent  _Z13test_control1v      <span class="c"># @_Z13test_control1v</span>
_Z13test_control1v:
        .cfi_startproc
        .frame        <span class="nv">$fp</span>,48,<span class="nv">$lr</span>
        .mask         0x00000800,-4
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:                                 # %entry</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -48
<span class="nv">$tmp3</span>:
        .cfi_def_cfa_offset 48
        st    <span class="nv">$fp</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp4</span>:
        .cfi_offset 11, -4
        addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
<span class="nv">$tmp5</span>:
        .cfi_def_cfa_register 11
        addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
        st    <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
        st    <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 2
        st    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 3
        st    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 4
        st    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 5
        st    <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 6
        st    <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 7
        st    <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 8
        st    <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 9
        st    <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_2</span>
<span class="c"># BB#1:                                 # %if.then</span>
        ld    <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_2</span>:                                 <span class="c"># %if.end</span>
        ld    <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        beq   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_4</span>
<span class="c"># BB#3:                                 # %if.then2</span>
        ld    <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_4</span>:                                 <span class="c"># %if.end4</span>
        ld    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slti  <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_6</span>
<span class="c"># BB#5:                                 # %if.then6</span>
        ld    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_6</span>:                                 <span class="c"># %if.end8</span>
        ld    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slti  <span class="nv">$4</span>, <span class="nv">$4</span>, 0
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_8</span>
<span class="c"># BB#7:                                 # %if.then10</span>
        ld    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_8</span>:                                 <span class="c"># %if.end12</span>
        ld    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$5</span>, <span class="nv">$zero</span>, -1
        slt   <span class="nv">$4</span>, <span class="nv">$5</span>, <span class="nv">$4</span>
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_10</span>
<span class="c"># BB#9:                                 # %if.then14</span>
        ld    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_10</span>:                                <span class="c"># %if.end16</span>
        ld    <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slt   <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        bne   <span class="nv">$3</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_12</span>
<span class="c"># BB#11:                                # %if.then18</span>
        ld    <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$3</span>, <span class="nv">$3</span>, 1
        st    <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_12</span>:                                <span class="c"># %if.end20</span>
        ld    <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slt   <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        bne   <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_14</span>
<span class="c"># BB#13:                                # %if.then22</span>
        ld    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_14</span>:                                <span class="c"># %if.end24</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        bne   <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_16</span>
<span class="c"># BB#15:                                # %if.then26</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_16</span>:                                <span class="c"># %if.end28</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slt   <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        beq   <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_18</span>
<span class="c"># BB#17:                                # %if.then30</span>
        ld    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_18</span>:                                <span class="c"># %if.end32</span>
        ld    <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        beq   <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$BB0_20</span>
<span class="c"># BB#19:                                # %if.then34</span>
        ld    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_20</span>:                                <span class="c"># %if.end36</span>
        ld    <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        ld    <span class="nv">$3</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
        ld    <span class="nv">$fp</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 48
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  _Z13test_control1v
<span class="nv">$tmp6</span>:
        .size _Z13test_control1v, <span class="o">(</span><span class="nv">$tmp6</span><span class="o">)</span>-_Z13test_control1v
        .cfi_endproc
</pre></div>
</div>
<p>The ch12_3.cpp is written in assembly for AsmParser test. You can check if it
will generate the obj.</p>
<table class="docutils footnote" frame="void" id="sra-note" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Rb &#8216;&gt;&gt; Cx, Rb &#8216;&gt;&gt; Rc: Shift with signed bit remain. It&#8217;s equal to ((Rb&amp;&#8217;h80000000)|Rb&gt;&gt;Cx) or ((Rb&amp;&#8217;h80000000)|Rb&gt;&gt;Rc).</td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="runbackend.html">Run backend</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lld.html">LLD for Cpu0</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>