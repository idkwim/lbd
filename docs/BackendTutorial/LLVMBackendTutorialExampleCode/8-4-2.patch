diff -Naur Chapter8_4/Cpu0InstrInfo.cpp Chapter8_4_2/Cpu0InstrInfo.cpp
--- Chapter8_4/Cpu0InstrInfo.cpp	2013-09-17 20:37:38.000000000 +0800
+++ Chapter8_4_2/Cpu0InstrInfo.cpp	2013-09-17 20:37:38.000000000 +0800
@@ -46,6 +46,8 @@
       Opc = Cpu0::MFLO, SrcReg = 0;
     else if (SrcReg == Cpu0::SW)	// add $ra, $ZERO, $SW
       Opc = Cpu0::ADD, ZeroReg = Cpu0::ZERO;
+    else if (SrcReg == Cpu0::ACC)
+      Opc = Cpu0::MFACC, SrcReg = 0;
   }
   else if (Cpu0::CPURegsRegClass.contains(SrcReg)) { // Copy from CPU Reg.
     if (DestReg == Cpu0::HI)
@@ -56,6 +58,8 @@
     //  cmp $SW, $ZERO, $rc
     else if (DestReg == Cpu0::SW)
       Opc = Cpu0::CMP, ZeroReg = Cpu0::ZERO;
+    else if (DestReg == Cpu0::ACC)
+      Opc = Cpu0::MTACC, DestReg = 0;
   }
 
   assert(Opc && "Cannot copy registers");
diff -Naur Chapter8_4/Cpu0InstrInfo.td Chapter8_4_2/Cpu0InstrInfo.td
--- Chapter8_4/Cpu0InstrInfo.td	2013-09-17 20:37:38.000000000 +0800
+++ Chapter8_4_2/Cpu0InstrInfo.td	2013-09-17 20:37:38.000000000 +0800
@@ -376,6 +376,36 @@
   let neverHasSideEffects = 1;
 }
 
+class MoveFromACC<bits<8> op, string instr_asm, RegisterClass RC,
+                   list<Register> UseRegs>:
+  FL<op, (outs RC:$ra), (ins),
+     !strconcat(instr_asm, "\t$ra"), [], IIAlu> {
+  let rb = 0;
+  let imm16 = 0;
+  let Uses = UseRegs;
+  let neverHasSideEffects = 1;
+}
+
+class MoveToACC<bits<8> op, string instr_asm, RegisterClass RC,
+                 list<Register> DefRegs>:
+  FL<op, (outs), (ins RC:$ra),
+     !strconcat(instr_asm, "\t$ra"), [], IIAlu> {
+  let rb = 0;
+  let imm16 = 0;
+  let Defs = DefRegs;
+  let neverHasSideEffects = 1;
+}
+
+class ArithLogicUniR2<bits<8> op, string instr_asm, RegisterClass RC1,
+                 RegisterClass RC2, list<Register> DefRegs>:
+  FL<op, (outs), (ins RC1:$accum, RC2:$ra),
+     !strconcat(instr_asm, "\t$ra"), [], IIAlu> {
+  let rb = 0;
+  let imm16 = 0;
+  let Defs = DefRegs;
+  let neverHasSideEffects = 1;
+}
+
 class EffectiveAddress<string instr_asm, RegisterClass RC, Operand Mem> :
   FMem<0x09, (outs RC:$ra), (ins Mem:$addr),
      instr_asm, [(set RC:$ra, addr:$addr)], IIAlu>;
@@ -440,6 +470,10 @@
 def OR      : ArithLogicR<0x19, "or", or, IIAlu, CPURegs, 1>;
 def XOR     : ArithLogicR<0x1a, "xor", xor, IIAlu, CPURegs, 1>;
 
+def MFACC : MoveFromACC<0x44, "mfacc", CPURegs, [ACC]>;
+def MTACC : MoveToACC<0x45, "mtacc", CPURegs, [ACC]>;
+def ADD   : ArithLogicUniR2<0x46, "add", RACC, CPURegs, [ACC]>;
+
 /// Shift Instructions
 // sra is IR node for ashr llvm IR instruction of .bc
 def ROL     : shift_rotate_imm32<0x1b, 0x01, "rol", rotl>;
@@ -546,6 +580,12 @@
 def : Pat<(sext_inreg CPURegs:$in, i8),
           (OR (SHL (ANDi CPURegs:$in, 0x8000), 16), (ANDi CPURegs:$in, 0x7fff))>;
 
+def : Pat<(add RACC:$lhs, CPURegs:$rhs),
+          (ADD RACC:$lhs, CPURegs:$rhs)>;
+
+def : Pat<(add CPURegs:$lhs, CPURegs:$rhs),
+          (ADD (MTACC CPURegs:$lhs), CPURegs:$rhs)>;
+
 // brcond patterns
 multiclass BrcondPats<RegisterClass RC, Instruction JEQOp, Instruction JNEOp, 
 Instruction JLTOp, Instruction JGTOp, Instruction JLEOp, Instruction JGEOp, 
diff -Naur Chapter8_4/Cpu0InstrInfo.td.orig Chapter8_4_2/Cpu0InstrInfo.td.orig
--- Chapter8_4/Cpu0InstrInfo.td.orig	2013-09-17 20:37:38.000000000 +0800
+++ Chapter8_4_2/Cpu0InstrInfo.td.orig	2013-09-17 20:37:38.000000000 +0800
@@ -26,6 +26,16 @@
                                          [SDTCisInt<0>,
                                           SDTCisSameAs<0, 1>]>;
 
+def SDT_Cpu0JmpLink      : SDTypeProfile<0, 1, [SDTCisVT<0, iPTR>]>;
+
+def SDT_Cpu0CallSeqStart : SDCallSeqStart<[SDTCisVT<0, i32>]>;
+def SDT_Cpu0CallSeqEnd   : SDCallSeqEnd<[SDTCisVT<0, i32>, SDTCisVT<1, i32>]>;
+
+// Call
+def Cpu0JmpLink : SDNode<"Cpu0ISD::JmpLink",SDT_Cpu0JmpLink,
+                         [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue,
+                          SDNPVariadic]>;
+
 // Hi and Lo nodes are used to handle global addresses. Used on
 // Cpu0ISelLowering to lower stuff like GlobalAddress, ExternalSymbol
 // static model. (nothing to do with Cpu0 Registers Hi and Lo)
@@ -34,8 +44,14 @@
 def Cpu0GPRel : SDNode<"Cpu0ISD::GPRel", SDTIntUnaryOp>;
 
 // Return
-def Cpu0Ret : SDNode<"Cpu0ISD::Ret", SDT_Cpu0Ret, [SDNPHasChain,
-                     SDNPOptInGlue]>;
+def Cpu0Ret : SDNode<"Cpu0ISD::Ret", SDTNone,
+                     [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]>;
+
+// These are target-independent nodes, but have target-specific formats.
+def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_Cpu0CallSeqStart,
+                           [SDNPHasChain, SDNPOutGlue]>;
+def callseq_end   : SDNode<"ISD::CALLSEQ_END", SDT_Cpu0CallSeqEnd,
+                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
 
 // DivRem(u) nodes
 def Cpu0DivRem    : SDNode<"Cpu0ISD::DivRem", SDT_Cpu0DivRem,
@@ -52,6 +68,16 @@
 //===----------------------------------------------------------------------===//
 // Cpu0 Operand, Complex Patterns and Transformations Definitions.
 //===----------------------------------------------------------------------===//
+// Instruction operand types
+def brtarget    : Operand<OtherVT> {
+  let EncoderMethod = "getBranchTargetOpValue";
+  let OperandType = "OPERAND_PCREL";
+  let DecoderMethod = "DecodeBranchTarget";
+}
+
+def calltarget  : Operand<iPTR> {
+  let EncoderMethod = "getJumpTargetOpValue";
+}
 
 // Signed Operand
 def simm16      : Operand<i32> {
@@ -245,6 +271,64 @@
   def #NAME# : StoreM<op, instr_asm, OpNode, CPURegs, mem, Pseudo>;
 }
 
+// Conditional Branch
+class CBranch<bits<8> op, string instr_asm, RegisterClass RC,
+                   list<Register> UseRegs>:
+  FJ<op, (outs), (ins RC:$ra, brtarget:$addr),
+             !strconcat(instr_asm, "\t$addr"),
+             [], IIBranch> {
+  let isBranch = 1;
+  let isTerminator = 1;
+  let hasDelaySlot = 0;
+  let neverHasSideEffects = 1;
+}
+
+// Unconditional branch, such as JMP
+class UncondBranch<bits<8> op, string instr_asm>:
+  FJ<op, (outs), (ins brtarget:$addr),
+             !strconcat(instr_asm, "\t$addr"), [(br bb:$addr)], IIBranch> {
+  let isBranch = 1;
+  let isTerminator = 1;
+  let isBarrier = 1;
+  let hasDelaySlot = 0;
+  let DecoderMethod = "DecodeJumpRelativeTarget";
+}
+
+let isBranch=1, isTerminator=1, isBarrier=1, imm16=0, hasDelaySlot = 1,
+    isIndirectBranch = 1 in
+class JumpFR<bits<8> op, string instr_asm, RegisterClass RC>:
+  FL<op, (outs), (ins RC:$ra),
+     !strconcat(instr_asm, "\t$ra"), [(brind RC:$ra)], IIBranch> {
+  let rb = 0;
+  let imm16 = 0;
+}
+
+// Return instruction
+class RetBase<RegisterClass RC>: JumpFR<0x3c, "ret", RC> {
+  let isReturn = 1;
+  let isCodeGenOnly = 1;
+  let hasCtrlDep = 1;
+  let hasExtraSrcRegAllocReq = 1;
+}
+
+// Jump and Link (Call)
+let isCall=1, hasDelaySlot=0 in {
+  class JumpLink<bits<8> op, string instr_asm>:
+    FJ<op, (outs), (ins calltarget:$target, variable_ops),
+       !strconcat(instr_asm, "\t$target"), [(Cpu0JmpLink imm:$target)],
+       IIBranch> {
+       }
+
+  class JumpLinkReg<bits<8> op, string instr_asm,
+                    RegisterClass RC>:
+    FA<op, (outs), (ins RC:$rb, variable_ops),
+       !strconcat(instr_asm, "\t$rb"), [(Cpu0JmpLink RC:$rb)], IIBranch> {
+    let rc = 0;
+    let ra = 14;
+    let shamt = 0;
+  }
+}
+
 // Mul, Div
 class Mult<bits<8> op, string instr_asm, InstrItinClass itin,
            RegisterClass RC, list<Register> DefRegs>:
@@ -297,6 +381,28 @@
      instr_asm, [(set RC:$ra, addr:$addr)], IIAlu>;
 
 //===----------------------------------------------------------------------===//
+// Pseudo instructions
+//===----------------------------------------------------------------------===//
+
+// As stack alignment is always done with addiu, we need a 16-bit immediate
+let Defs = [SP], Uses = [SP] in {
+def ADJCALLSTACKDOWN : Cpu0Pseudo<(outs), (ins uimm16:$amt),
+                                  "!ADJCALLSTACKDOWN $amt",
+                                  [(callseq_start timm:$amt)]>;
+def ADJCALLSTACKUP   : Cpu0Pseudo<(outs), (ins uimm16:$amt1, uimm16:$amt2),
+                                  "!ADJCALLSTACKUP $amt1",
+                                  [(callseq_end timm:$amt1, timm:$amt2)]>;
+}
+
+// When handling PIC code the assembler needs .cpload and .cprestore
+// directives. If the real instructions corresponding these directives
+// are used, we have the same behavior, but get also a bunch of warnings
+// from the assembler.
+let neverHasSideEffects = 1 in
+def CPRESTORE : Cpu0Pseudo<(outs), (ins i32imm:$loc, CPURegs:$gp),
+                           ".cprestore\t$loc", []>;
+
+//===----------------------------------------------------------------------===//
 // Instruction definition
 //===----------------------------------------------------------------------===//
 
@@ -346,10 +452,26 @@
 def SHLV    : shift_rotate_reg<0x21, 0x00, "shlv", shl, CPURegs>;
 def SHRV    : shift_rotate_reg<0x22, 0x00, "shrv", srl, CPURegs>;
 
-let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1,
-    isBarrier=1, hasCtrlDep=1 in
-  def RET : FJ <0x2c, (outs), (ins CPURegs:$target),
-                "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch>;
+/// Jump and Branch Instructions
+def JEQ     : CBranch<0x30, "jeq", SR, [SW]>;
+def JNE     : CBranch<0x31, "jne", SR, [SW]>;
+def JLT     : CBranch<0x32, "jlt", SR, [SW]>;
+def JGT     : CBranch<0x33, "jgt", SR, [SW]>;
+def JLE     : CBranch<0x34, "jle", SR, [SW]>;
+def JGE     : CBranch<0x35, "jge", SR, [SW]>;
+
+def JMP     : UncondBranch<0x36, "jmp">;
+
+/// Jump and Branch Instructions
+def SWI     : JumpLink<0x3a, "swi">;
+def JSUB    : JumpLink<0x3b, "jsub">;
+
+let isReturn=1, isTerminator=1, hasDelaySlot=1, isBarrier=1, hasCtrlDep=1 in
+  def RetLR : Cpu0Pseudo<(outs), (ins), "", [(Cpu0Ret)]>;
+
+def RET     : RetBase<CPURegs>;
+
+def JALR    : JumpLinkReg<0x3e, "jalr", CPURegs>;
 
 /// Multiply and Divide Instructions.
 def MULT    : Mult32<0x41, "mult", IIImul>;
@@ -390,6 +512,11 @@
 def : Pat<(i32 imm:$imm),
           (ORi (LUi (HI16 imm:$imm)), (LO16 imm:$imm))>;
 
+def : Pat<(Cpu0JmpLink (i32 tglobaladdr:$dst)),
+          (JSUB tglobaladdr:$dst)>;
+def : Pat<(Cpu0JmpLink (i32 texternalsym:$dst)),
+          (JSUB texternalsym:$dst)>;
+
 // hi/lo relocs
 def : Pat<(Cpu0Hi tglobaladdr:$in), (SHL (ADDiu ZERO, tglobaladdr:$in), 16)>;
 def : Pat<(Cpu0Hi tglobaladdr:$in), (LUi tglobaladdr:$in)>;
@@ -419,6 +546,41 @@
 def : Pat<(sext_inreg CPURegs:$in, i8),
           (OR (SHL (ANDi CPURegs:$in, 0x8000), 16), (ANDi CPURegs:$in, 0x7fff))>;
 
+// brcond patterns
+multiclass BrcondPats<RegisterClass RC, Instruction JEQOp, Instruction JNEOp, 
+Instruction JLTOp, Instruction JGTOp, Instruction JLEOp, Instruction JGEOp, 
+Instruction CMPOp, Register ZEROReg> {
+def : Pat<(brcond (i32 (seteq RC:$lhs, RC:$rhs)), bb:$dst),
+          (JEQOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setueq RC:$lhs, RC:$rhs)), bb:$dst),
+          (JEQOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setne RC:$lhs, RC:$rhs)), bb:$dst),
+          (JNEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setune RC:$lhs, RC:$rhs)), bb:$dst),
+          (JNEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setlt RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setult RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setgt RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setugt RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setle RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLEOp (CMPOp RC:$rhs, RC:$lhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setule RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLEOp (CMPOp RC:$rhs, RC:$lhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setge RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setuge RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+
+def : Pat<(brcond RC:$cond, bb:$dst),
+          (JNEOp (CMPOp RC:$cond, ZEROReg), bb:$dst)>;
+}
+
+defm : BrcondPats<CPURegs, JEQ, JNE, JLT, JGT, JLE, JGE, CMP, ZERO>;
+
 // setcc patterns
 multiclass SeteqPats<RegisterClass RC> {
 // a == b
diff -Naur Chapter8_4/Cpu0RegisterInfo.td Chapter8_4_2/Cpu0RegisterInfo.td
--- Chapter8_4/Cpu0RegisterInfo.td	2013-09-17 20:37:38.000000000 +0800
+++ Chapter8_4_2/Cpu0RegisterInfo.td	2013-09-17 20:37:38.000000000 +0800
@@ -51,6 +51,8 @@
   // Hi/Lo registers
   def HI   : Register<"hi">, DwarfRegNum<[18]>;
   def LO   : Register<"lo">, DwarfRegNum<[19]>;
+
+  def ACC : Register<"acc">, DwarfRegNum<[20]>;
 }
 
 //===----------------------------------------------------------------------===//
@@ -78,3 +80,5 @@
 
 // Status Registers
 def SR   : RegisterClass<"Cpu0", [i32], 32, (add SW)>;
+
+def RACC : RegisterClass<"Cpu0", [i32], 32, (add ACC)>;
