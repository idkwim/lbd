diff -Naur Chapter11_1/AsmParser/Cpu0AsmParser.cpp Chapter11_2/AsmParser/Cpu0AsmParser.cpp
--- Chapter11_1/AsmParser/Cpu0AsmParser.cpp	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/AsmParser/Cpu0AsmParser.cpp	2013-09-12 15:08:42.133586839 +0800
@@ -481,7 +481,7 @@
       .Case("s2",  Cpu0::S2)
       .Case("gp",  Cpu0::GP)
       .Case("fp",  Cpu0::FP)
-      .Case("sw",  Cpu0::SW)
+      .Case("t0",  Cpu0::T0)
       .Case("sp",  Cpu0::SP)
       .Case("lr",  Cpu0::LR)
       .Case("pc",  Cpu0::PC)
diff -Naur Chapter11_1/Cpu0InstrInfo.cpp Chapter11_2/Cpu0InstrInfo.cpp
--- Chapter11_1/Cpu0InstrInfo.cpp	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/Cpu0InstrInfo.cpp	2013-09-12 15:08:42.133586839 +0800
@@ -44,18 +44,12 @@
       Opc = Cpu0::MFHI, SrcReg = 0;
     else if (SrcReg == Cpu0::LO)
       Opc = Cpu0::MFLO, SrcReg = 0;
-    else if (SrcReg == Cpu0::SW)	// add $ra, $ZERO, $SW
-      Opc = Cpu0::ADD, ZeroReg = Cpu0::ZERO;
   }
   else if (Cpu0::CPURegsRegClass.contains(SrcReg)) { // Copy from CPU Reg.
     if (DestReg == Cpu0::HI)
       Opc = Cpu0::MTHI, DestReg = 0;
     else if (DestReg == Cpu0::LO)
       Opc = Cpu0::MTLO, DestReg = 0;
-    // Only possibility in (DestReg==SW, SrcReg==CPU0Regs) is 
-    //  cmp $SW, $ZERO, $rc
-    else if (DestReg == Cpu0::SW)
-      Opc = Cpu0::CMP, ZeroReg = Cpu0::ZERO;
   }
 
   assert(Opc && "Cannot copy registers");
diff -Naur Chapter11_1/Cpu0InstrInfo.td Chapter11_2/Cpu0InstrInfo.td
--- Chapter11_1/Cpu0InstrInfo.td	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/Cpu0InstrInfo.td	2013-09-12 15:08:42.133586839 +0800
@@ -75,6 +75,12 @@
   let DecoderMethod = "DecodeBranchTarget";
 }
 
+def jmptarget    : Operand<OtherVT> {
+  let EncoderMethod = "getJumpTargetOpValue";
+  let OperandType = "OPERAND_PCREL";
+  let DecoderMethod = "DecodeJumpRelativeTarget";
+}
+
 def calltarget  : Operand<iPTR> {
   let EncoderMethod = "getJumpTargetOpValue";
 }
@@ -141,6 +147,12 @@
   return isInt<32>(Val) && !(Val & 0xffff);
 }]>;
 
+// Immediate can be loaded with LUi (32-bit int with lower 16-bit cleared).
+def immLow16Zero : PatLeaf<(imm), [{
+  int64_t Val = N->getSExtValue();
+  return isInt<32>(Val) && !(Val & 0xffff);
+}]>;
+
 // shamt field must fit in 5 bits.
 def immZExt5 : ImmLeaf<i32, [{return Imm == (Imm & 0x1f);}]>;
 
@@ -187,15 +199,12 @@
   let isReMaterializable = 1;
 }
 
-class CmpInstr<bits<8> op, string instr_asm, 
-               InstrItinClass itin, RegisterClass RC, RegisterClass RD, 
-               bit isComm = 0>:
-  FA<op, (outs RD:$rc), (ins RC:$ra, RC:$rb),
-     !strconcat(instr_asm, "\t$rc, $ra, $rb"), [], itin> {
-  let rc = 0;
+class ArithOverflowR<bits<8> op, string instr_asm,
+                    InstrItinClass itin, RegisterClass RC, bit isComm = 0>:
+  FA<op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
+     !strconcat(instr_asm, "\t$ra, $rb, $rc"), [], itin> {
   let shamt = 0;
   let isCommutable = isComm;
-  let DecoderMethod = "DecodeCMPInstruction";
 }
 
 // Arithmetic and logical instructions with 2 register operands.
@@ -279,27 +288,41 @@
 }
 
 // Conditional Branch
-class CBranch<bits<8> op, string instr_asm, RegisterClass RC,
-                   list<Register> UseRegs>:
-  FJ<op, (outs), (ins RC:$ra, brtarget:$addr),
-             !strconcat(instr_asm, "\t$ra, $addr"),
-             [(brcond RC:$ra, bb:$addr)], IIBranch> {
+class CBranch<bits<8> op, string instr_asm, PatFrag cond_op, RegisterClass RC>:
+  FL<op, (outs), (ins RC:$ra, RC:$rb, brtarget:$imm16),
+             !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
+             [(brcond (i32 (cond_op RC:$ra, RC:$rb)), bb:$imm16)], IIBranch> {
   let isBranch = 1;
   let isTerminator = 1;
-  let hasDelaySlot = 0;
-  let neverHasSideEffects = 1;
-  let DecoderMethod = "DecodeBranchTarget";
+  let hasDelaySlot = 1;
+  let Defs = [AT];
 }
 
+// SetCC
+class SetCC_R<bits<8> op, string instr_asm, PatFrag cond_op,
+              RegisterClass RC>:
+  FA<op, (outs CPURegs:$ra), (ins RC:$rb, RC:$rc),
+     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
+     [(set CPURegs:$ra, (cond_op RC:$rb, RC:$rc))],
+     IIAlu> {
+  let shamt = 0;
+}
+
+class SetCC_I<bits<8> op, string instr_asm, PatFrag cond_op, Operand Od,
+              PatLeaf imm_type, RegisterClass RC>:
+  FL<op, (outs CPURegs:$ra), (ins RC:$rb, Od:$imm16),
+     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
+     [(set CPURegs:$ra, (cond_op RC:$rb, imm_type:$imm16))],
+     IIAlu>;
+
 // Unconditional branch, such as JMP
 class UncondBranch<bits<8> op, string instr_asm>:
-  FJ<op, (outs), (ins brtarget:$addr),
+  FJ<op, (outs), (ins jmptarget:$addr),
              !strconcat(instr_asm, "\t$addr"), [(br bb:$addr)], IIBranch> {
   let isBranch = 1;
   let isTerminator = 1;
   let isBarrier = 1;
   let hasDelaySlot = 0;
-  let DecoderMethod = "DecodeJumpRelativeTarget";
 }
 
 let isBranch=1, isTerminator=1, isBarrier=1, imm16=0, hasDelaySlot = 1,
@@ -477,12 +500,8 @@
 def SHRV    : shift_rotate_reg<0x22, 0x00, "shrv", srl, CPURegs>;
 
 /// Jump and Branch Instructions
-def JEQ     : CBranch<0x20, "jeq", SR, [SW]>;
-def JNE     : CBranch<0x21, "jne", SR, [SW]>;
-def JLT     : CBranch<0x22, "jlt", SR, [SW]>;
-def JGT     : CBranch<0x23, "jgt", SR, [SW]>;
-def JLE     : CBranch<0x24, "jle", SR, [SW]>;
-def JGE     : CBranch<0x25, "jge", SR, [SW]>;
+def BEQ     : CBranch<0x20, "beq", seteq, CPURegs>;
+def BNE     : CBranch<0x21, "bne", setne, CPURegs>;
 
 def JMP     : UncondBranch<0x26, "jmp">;
 
diff -Naur Chapter11_1/Cpu0RegisterInfo.td Chapter11_2/Cpu0RegisterInfo.td
--- Chapter11_1/Cpu0RegisterInfo.td	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/Cpu0RegisterInfo.td	2013-09-12 15:08:42.133586839 +0800
@@ -41,7 +41,7 @@
   def S2   : Cpu0GPRReg< 9, "9">,    DwarfRegNum<[9]>;
   def GP   : Cpu0GPRReg< 10, "gp">,  DwarfRegNum<[10]>;
   def FP   : Cpu0GPRReg< 11, "fp">,  DwarfRegNum<[11]>;
-  def SW   : Cpu0GPRReg< 12, "sw">,   DwarfRegNum<[12]>;
+  def T0   : Cpu0GPRReg< 12, "t0">,   DwarfRegNum<[12]>;
   def SP   : Cpu0GPRReg< 13, "sp">,   DwarfRegNum<[13]>;
   def LR   : Cpu0GPRReg< 14, "lr">,   DwarfRegNum<[14]>;
   def PC   : Cpu0GPRReg< 15, "pc">,   DwarfRegNum<[15]>;
@@ -69,12 +69,9 @@
   // Reserved
   GP, FP, 
   // Not preserved across procedure calls
-  SW, 
+  T0, 
   // Reserved
   SP, LR, PC)>;
 
 // Hi/Lo Registers
 def HILO : RegisterClass<"Cpu0", [i32], 32, (add HI, LO)>;
-
-// Status Registers
-def SR   : RegisterClass<"Cpu0", [i32], 32, (add SW)>;
diff -Naur Chapter11_1/Disassembler/Cpu0Disassembler.cpp Chapter11_2/Disassembler/Cpu0Disassembler.cpp
--- Chapter11_1/Disassembler/Cpu0Disassembler.cpp	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/Disassembler/Cpu0Disassembler.cpp	2013-09-12 15:08:42.133586839 +0800
@@ -55,7 +55,7 @@
   Cpu0::ZERO, Cpu0::AT, Cpu0::V0, Cpu0::V1,
   Cpu0::A0, Cpu0::A1, Cpu0::T9, Cpu0::S0, 
   Cpu0::S1, Cpu0::S2, Cpu0::GP, Cpu0::FP, 
-  Cpu0::SW, Cpu0::SP, Cpu0::LR, Cpu0::PC
+  Cpu0::T0, Cpu0::SP, Cpu0::LR, Cpu0::PC
 };
 
 static DecodeStatus DecodeCPURegsRegisterClass(MCInst &Inst,
@@ -200,71 +200,13 @@
   return MCDisassembler::Success;
 }
 
-/* CMP instruction define $rc and then $ra, $rb; The printOperand() print 
-operand 1 and operand 2 (operand 0 is $rc and operand 1 is $ra), so we Create 
-register $rc first and create $ra next, as follows,
-
-// Cpu0InstrInfo.td
-class CmpInstr<bits<8> op, string instr_asm, 
-                    InstrItinClass itin, RegisterClass RC, RegisterClass RD, bit isComm = 0>:
-  FA<op, (outs RD:$rc), (ins RC:$ra, RC:$rb),
-     !strconcat(instr_asm, "\t$ra, $rb"), [], itin> {
-
-// Cpu0AsmWriter.inc
-void Cpu0InstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
-...
-  case 3:
-    // CMP, JEQ, JGE, JGT, JLE, JLT, JNE
-    printOperand(MI, 1, O); 
-    break;
-...
-  case 1:
-    // CMP
-    printOperand(MI, 2, O); 
-    return;
-    break;
-*/
-static DecodeStatus DecodeCMPInstruction(MCInst &Inst,
-                                       unsigned Insn,
-                                       uint64_t Address,
-                                       const void *Decoder) {
-  int Reg_a = (int)fieldFromInstruction(Insn, 20, 4);
-  int Reg_b = (int)fieldFromInstruction(Insn, 16, 4);
-  int Reg_c = (int)fieldFromInstruction(Insn, 12, 4);
-
-  Inst.addOperand(MCOperand::CreateReg(CPURegsTable[Reg_c]));
-  Inst.addOperand(MCOperand::CreateReg(CPURegsTable[Reg_a]));
-  Inst.addOperand(MCOperand::CreateReg(CPURegsTable[Reg_b]));
-  return MCDisassembler::Success;
-}
-
-/* CBranch instruction define $ra and then imm24; The printOperand() print 
-operand 1 (operand 0 is $ra and operand 1 is imm24), so we Create register 
-operand first and create imm24 next, as follows,
-
-// Cpu0InstrInfo.td
-class CBranch<bits<8> op, string instr_asm, RegisterClass RC,
-                   list<Register> UseRegs>:
-  FJ<op, (outs), (ins RC:$ra, brtarget:$addr),
-             !strconcat(instr_asm, "\t$addr"),
-             [(brcond RC:$ra, bb:$addr)], IIBranch> {
-
-// Cpu0AsmWriter.inc
-void Cpu0InstPrinter::printInstruction(const MCInst *MI, raw_ostream &O) {
-...
-  case 3:
-    // CMP, JEQ, JGE, JGT, JLE, JLT, JNE
-    printOperand(MI, 1, O); 
-    break;
-*/
 static DecodeStatus DecodeBranchTarget(MCInst &Inst,
                                        unsigned Insn,
                                        uint64_t Address,
                                        const void *Decoder) {
-  int BranchOffset = fieldFromInstruction(Insn, 0, 24);
-  if (BranchOffset > 0x8fffff)
-  	BranchOffset = -1*(0x1000000 - BranchOffset);
-  Inst.addOperand(MCOperand::CreateReg(CPURegsTable[0]));
+  int BranchOffset = fieldFromInstruction(Insn, 0, 16);
+  if (BranchOffset > 0x8fff)
+  	BranchOffset = -1*(0x10000 - BranchOffset);
   Inst.addOperand(MCOperand::CreateImm(BranchOffset));
   return MCDisassembler::Success;
 }
diff -Naur Chapter11_1/MCTargetDesc/Cpu0AsmBackend.cpp Chapter11_2/MCTargetDesc/Cpu0AsmBackend.cpp
--- Chapter11_1/MCTargetDesc/Cpu0AsmBackend.cpp	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/MCTargetDesc/Cpu0AsmBackend.cpp	2013-09-12 15:08:42.133586839 +0800
@@ -38,6 +38,7 @@
   case Cpu0::fixup_Cpu0_LO16:
   case Cpu0::fixup_Cpu0_GOT_LO16:
     break;
+  case Cpu0::fixup_Cpu0_PC16:
   case Cpu0::fixup_Cpu0_PC24:
     // So far we are only using this type for branches.
     // For branches we start 1 instruction after the branch
@@ -142,6 +143,7 @@
       { "fixup_Cpu0_LITERAL",      0,     16,   0 },
       { "fixup_Cpu0_GOT_Global",   0,     16,   0 },
       { "fixup_Cpu0_GOT_Local",    0,     16,   0 },
+      { "fixup_Cpu0_PC16",         0,     16,  MCFixupKindInfo::FKF_IsPCRel },
       { "fixup_Cpu0_PC24",         0,     24,  MCFixupKindInfo::FKF_IsPCRel },
       { "fixup_Cpu0_CALL24",       0,     24,   0 },
       { "fixup_Cpu0_GPREL32",      0,     32,   0 },
diff -Naur Chapter11_1/MCTargetDesc/Cpu0BaseInfo.h Chapter11_2/MCTargetDesc/Cpu0BaseInfo.h
--- Chapter11_1/MCTargetDesc/Cpu0BaseInfo.h	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/MCTargetDesc/Cpu0BaseInfo.h	2013-09-12 15:08:42.133586839 +0800
@@ -139,7 +139,7 @@
     return 10;
   case Cpu0::FP:
     return 11;
-  case Cpu0::SW:
+  case Cpu0::T0:
     return 12;
   case Cpu0::SP:
     return 13;
diff -Naur Chapter11_1/MCTargetDesc/Cpu0FixupKinds.h Chapter11_2/MCTargetDesc/Cpu0FixupKinds.h
--- Chapter11_1/MCTargetDesc/Cpu0FixupKinds.h	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/MCTargetDesc/Cpu0FixupKinds.h	2013-09-12 15:08:42.133586839 +0800
@@ -53,8 +53,12 @@
     // Local symbol fixup resulting in - R_CPU0_GOT16.
     fixup_Cpu0_GOT_Local,
 
+    // PC relative branch fixup resulting in - R_CPU0_PC16.
+    // cpu0 PC16, e.g. beq
+    fixup_Cpu0_PC16,
+    
     // PC relative branch fixup resulting in - R_CPU0_PC24.
-    // cpu0 PC24, e.g. jeq
+    // cpu0 PC24, e.g. jmp
     fixup_Cpu0_PC24,
 
     // resulting in - R_CPU0_CALL24.
diff -Naur Chapter11_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp Chapter11_2/MCTargetDesc/Cpu0MCCodeEmitter.cpp
--- Chapter11_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2013-09-12 15:08:42.141586839 +0800
+++ Chapter11_2/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2013-09-12 15:08:42.133586839 +0800
@@ -158,7 +158,7 @@
 
   const MCExpr *Expr = MO.getExpr();
   Fixups.push_back(MCFixup::Create(0, Expr,
-                                   MCFixupKind(Cpu0::fixup_Cpu0_PC24)));
+                                   MCFixupKind(Cpu0::fixup_Cpu0_PC16)));
   return 0;
 }
 
@@ -177,7 +177,7 @@
   assert(MO.isExpr() && "getJumpTargetOpValue expects only expressions");
 
   const MCExpr *Expr = MO.getExpr();
-  if (Opcode == Cpu0::JSUB)
+  if (Opcode == Cpu0::JSUB || Opcode == Cpu0::JMP)
     Fixups.push_back(MCFixup::Create(0, Expr,
                                      MCFixupKind(Cpu0::fixup_Cpu0_PC24)));
   else if (Opcode == Cpu0::SWI)
