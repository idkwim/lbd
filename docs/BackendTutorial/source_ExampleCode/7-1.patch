diff -Naur Chapter6_3/Cpu0InstrInfo.cpp Chapter7_1/Cpu0InstrInfo.cpp
--- Chapter6_3/Cpu0InstrInfo.cpp	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/Cpu0InstrInfo.cpp	2013-09-12 16:56:38.385586066 +0800
@@ -43,12 +43,18 @@
       Opc = Cpu0::MFHI, SrcReg = 0;
     else if (SrcReg == Cpu0::LO)
       Opc = Cpu0::MFLO, SrcReg = 0;
+    else if (SrcReg == Cpu0::SW)	// add $ra, $ZERO, $SW
+      Opc = Cpu0::ADD, ZeroReg = Cpu0::ZERO;
   }
   else if (Cpu0::CPURegsRegClass.contains(SrcReg)) { // Copy from CPU Reg.
     if (DestReg == Cpu0::HI)
       Opc = Cpu0::MTHI, DestReg = 0;
     else if (DestReg == Cpu0::LO)
       Opc = Cpu0::MTLO, DestReg = 0;
+    // Only possibility in (DestReg==SW, SrcReg==CPU0Regs) is 
+    //  cmp $SW, $ZERO, $rc
+    else if (DestReg == Cpu0::SW)
+      Opc = Cpu0::CMP, ZeroReg = Cpu0::ZERO;
   }
 
   assert(Opc && "Cannot copy registers");
diff -Naur Chapter6_3/Cpu0InstrInfo.td Chapter7_1/Cpu0InstrInfo.td
--- Chapter6_3/Cpu0InstrInfo.td	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/Cpu0InstrInfo.td	2013-09-12 16:56:38.385586066 +0800
@@ -52,6 +52,12 @@
 //===----------------------------------------------------------------------===//
 // Cpu0 Operand, Complex Patterns and Transformations Definitions.
 //===----------------------------------------------------------------------===//
+// Instruction operand types
+def brtarget    : Operand<OtherVT> {
+  let EncoderMethod = "getBranchTargetOpValue";
+  let OperandType = "OPERAND_PCREL";
+  let DecoderMethod = "DecodeBranchTarget";
+}
 
 // Signed Operand
 def simm16      : Operand<i32> {
@@ -245,6 +251,29 @@
   def #NAME# : StoreM<op, instr_asm, OpNode, CPURegs, mem, Pseudo>;
 }
 
+// Conditional Branch
+class CBranch<bits<8> op, string instr_asm, RegisterClass RC,
+                   list<Register> UseRegs>:
+  FJ<op, (outs), (ins RC:$ra, brtarget:$addr),
+             !strconcat(instr_asm, "\t$addr"),
+             [], IIBranch> {
+  let isBranch = 1;
+  let isTerminator = 1;
+  let hasDelaySlot = 0;
+  let neverHasSideEffects = 1;
+}
+
+// Unconditional branch, such as JMP
+class UncondBranch<bits<8> op, string instr_asm>:
+  FJ<op, (outs), (ins brtarget:$addr),
+             !strconcat(instr_asm, "\t$addr"), [(br bb:$addr)], IIBranch> {
+  let isBranch = 1;
+  let isTerminator = 1;
+  let isBarrier = 1;
+  let hasDelaySlot = 0;
+  let DecoderMethod = "DecodeJumpRelativeTarget";
+}
+
 // Mul, Div
 class Mult<bits<8> op, string instr_asm, InstrItinClass itin,
            RegisterClass RC, list<Register> DefRegs>:
@@ -346,6 +375,17 @@
 def SHLV    : shift_rotate_reg<0x21, 0x00, "shlv", shl, CPURegs>;
 def SHRV    : shift_rotate_reg<0x22, 0x00, "shrv", srl, CPURegs>;
 
+/// Jump and Branch Instructions
+def JEQ     : CBranch<0x30, "jeq", SR, [SW]>;
+def JNE     : CBranch<0x31, "jne", SR, [SW]>;
+def JLT     : CBranch<0x32, "jlt", SR, [SW]>;
+def JGT     : CBranch<0x33, "jgt", SR, [SW]>;
+def JLE     : CBranch<0x34, "jle", SR, [SW]>;
+def JGE     : CBranch<0x35, "jge", SR, [SW]>;
+
+def JMP     : UncondBranch<0x36, "jmp">;
+
+
 let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1,
     isBarrier=1, hasCtrlDep=1 in
   def RET : FJ <0x2c, (outs), (ins CPURegs:$target),
@@ -419,6 +459,41 @@
 def : Pat<(sext_inreg CPURegs:$in, i8),
           (OR (ANDi CPURegs:$in, 0x8000), (ANDi CPURegs:$in, 0x7fff))>;
 
+// brcond patterns
+multiclass BrcondPats<RegisterClass RC, Instruction JEQOp, Instruction JNEOp, 
+Instruction JLTOp, Instruction JGTOp, Instruction JLEOp, Instruction JGEOp, 
+Instruction CMPOp, Register ZEROReg> {
+def : Pat<(brcond (i32 (seteq RC:$lhs, RC:$rhs)), bb:$dst),
+          (JEQOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setueq RC:$lhs, RC:$rhs)), bb:$dst),
+          (JEQOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setne RC:$lhs, RC:$rhs)), bb:$dst),
+          (JNEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setune RC:$lhs, RC:$rhs)), bb:$dst),
+          (JNEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setlt RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setult RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setgt RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setugt RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGTOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setle RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLEOp (CMPOp RC:$rhs, RC:$lhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setule RC:$lhs, RC:$rhs)), bb:$dst),
+          (JLEOp (CMPOp RC:$rhs, RC:$lhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setge RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+def : Pat<(brcond (i32 (setuge RC:$lhs, RC:$rhs)), bb:$dst),
+          (JGEOp (CMPOp RC:$lhs, RC:$rhs), bb:$dst)>;
+
+def : Pat<(brcond RC:$cond, bb:$dst),
+          (JNEOp (CMPOp RC:$cond, ZEROReg), bb:$dst)>;
+}
+
+defm : BrcondPats<CPURegs, JEQ, JNE, JLT, JGT, JLE, JGE, CMP, ZERO>;
+
 // setcc patterns
 multiclass SeteqPats<RegisterClass RC> {
 // a == b
diff -Naur Chapter6_3/Cpu0ISelLowering.cpp Chapter7_1/Cpu0ISelLowering.cpp
--- Chapter6_3/Cpu0ISelLowering.cpp	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/Cpu0ISelLowering.cpp	2013-09-12 16:56:38.385586066 +0800
@@ -132,14 +132,24 @@
   setLoadExtAction(ISD::ZEXTLOAD, MVT::i1,  Promote);
   setLoadExtAction(ISD::SEXTLOAD, MVT::i1,  Promote);
 
+  // Used by legalize types to correctly generate the setcc result.
+  // Without this, every float setcc comes with a AND/OR with the result,
+  // we don't want this, since the fpcmp result goes to a flag register,
+  // which is used implicitly by brcond and select operations.
+  AddPromotedToType(ISD::SETCC, MVT::i1, MVT::i32);
+
   // Cpu0 Custom Operations
   setOperationAction(ISD::GlobalAddress,      MVT::i32,   Custom);
-
+  setOperationAction(ISD::BRCOND,             MVT::Other, Custom);
+  
   setOperationAction(ISD::SDIV, MVT::i32, Expand);
   setOperationAction(ISD::SREM, MVT::i32, Expand);
   setOperationAction(ISD::UDIV, MVT::i32, Expand);
   setOperationAction(ISD::UREM, MVT::i32, Expand);
 
+  // Operations not directly supported by Cpu0.
+  setOperationAction(ISD::BR_CC,             MVT::i32, Expand);
+
   setTargetDAGCombine(ISD::SDIVREM);
   setTargetDAGCombine(ISD::UDIVREM);
 
@@ -209,6 +219,7 @@
 {
   switch (Op.getOpcode())
   {
+    case ISD::BRCOND:             return LowerBRCOND(Op, DAG);
     case ISD::GlobalAddress:      return LowerGlobalAddress(Op, DAG);
   }
   return SDValue();
@@ -221,6 +232,11 @@
 //===----------------------------------------------------------------------===//
 //  Misc Lower Operation implementation
 //===----------------------------------------------------------------------===//
+SDValue Cpu0TargetLowering::
+LowerBRCOND(SDValue Op, SelectionDAG &DAG) const
+{
+  return Op;
+}
 
 SDValue Cpu0TargetLowering::LowerGlobalAddress(SDValue Op,
                                                SelectionDAG &DAG) const {
@@ -263,6 +279,12 @@
 
 #include "Cpu0GenCallingConv.inc"
 
+SDValue
+Cpu0TargetLowering::LowerCall(TargetLowering::CallLoweringInfo &CLI,
+                              SmallVectorImpl<SDValue> &InVals) const {
+  return CLI.Chain;
+}
+
 /// LowerFormalArguments - transform physical registers into virtual registers
 /// and generate load operations for arguments places on the stack.
 SDValue
diff -Naur Chapter6_3/Cpu0ISelLowering.h Chapter7_1/Cpu0ISelLowering.h
--- Chapter6_3/Cpu0ISelLowering.h	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/Cpu0ISelLowering.h	2013-09-12 16:56:38.385586066 +0800
@@ -87,6 +87,7 @@
     const Cpu0Subtarget *Subtarget;
 
     // Lower Operand specifics
+    SDValue LowerBRCOND(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerGlobalAddress(SDValue Op, SelectionDAG &DAG) const;
 
 	//- must be exist without function all
@@ -97,6 +98,10 @@
                            DebugLoc dl, SelectionDAG &DAG,
                            SmallVectorImpl<SDValue> &InVals) const;
 
+    virtual SDValue
+      LowerCall(TargetLowering::CallLoweringInfo &CLI,
+                SmallVectorImpl<SDValue> &InVals) const;
+
 	//- must be exist without function all
     virtual SDValue
       LowerReturn(SDValue Chain,
diff -Naur Chapter6_3/Cpu0MCInstLower.cpp Chapter7_1/Cpu0MCInstLower.cpp
--- Chapter6_3/Cpu0MCInstLower.cpp	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/Cpu0MCInstLower.cpp	2013-09-12 16:56:38.385586066 +0800
@@ -42,6 +42,8 @@
 
   switch(MO.getTargetFlags()) {
   default:                   llvm_unreachable("Invalid target flag!");
+  case Cpu0II::MO_NO_FLAG:   Kind = MCSymbolRefExpr::VK_None; break;
+
 // Cpu0_GPREL is for llc -march=cpu0 -relocation-model=static -cpu0-islinux-
 //  format=false (global var in .sdata).
   case Cpu0II::MO_GPREL:     Kind = MCSymbolRefExpr::VK_Cpu0_GPREL; break;
@@ -57,10 +59,19 @@
   }
 
   switch (MOTy) {
+  case MachineOperand::MO_MachineBasicBlock:
+    Symbol = MO.getMBB()->getSymbol();
+    break;
+
   case MachineOperand::MO_GlobalAddress:
     Symbol = Mang->getSymbol(MO.getGlobal());
     break;
 
+  case MachineOperand::MO_BlockAddress:
+    Symbol = AsmPrinter.GetBlockAddressSymbol(MO.getBlockAddress());
+    Offset += MO.getOffset();
+    break;
+
   default:
     llvm_unreachable("<unknown operand type>");
   }
@@ -124,7 +135,9 @@
     return MCOperand::CreateReg(MO.getReg());
   case MachineOperand::MO_Immediate:
     return MCOperand::CreateImm(MO.getImm() + offset);
+  case MachineOperand::MO_MachineBasicBlock:
   case MachineOperand::MO_GlobalAddress:
+  case MachineOperand::MO_BlockAddress:
     return LowerSymbolOperand(MO, MOTy, offset);
   case MachineOperand::MO_RegisterMask:
     break;
diff -Naur Chapter6_3/InstPrinter/Cpu0InstPrinter.cpp Chapter7_1/InstPrinter/Cpu0InstPrinter.cpp
--- Chapter6_3/InstPrinter/Cpu0InstPrinter.cpp	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/InstPrinter/Cpu0InstPrinter.cpp	2013-09-12 16:56:38.385586066 +0800
@@ -58,6 +58,7 @@
   case MCSymbolRefExpr::VK_None:           break;
 // Cpu0_GPREL is for llc -march=cpu0 -relocation-model=static
   case MCSymbolRefExpr::VK_Cpu0_GPREL:     OS << "%gp_rel("; break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT_CALL:  OS << "%call24("; break;
   case MCSymbolRefExpr::VK_Cpu0_GOT16:     OS << "%got(";    break;
   case MCSymbolRefExpr::VK_Cpu0_GOT:       OS << "%got(";    break;
   case MCSymbolRefExpr::VK_Cpu0_ABS_HI:    OS << "%hi(";     break;
diff -Naur Chapter6_3/MCTargetDesc/Cpu0BaseInfo.h Chapter7_1/MCTargetDesc/Cpu0BaseInfo.h
--- Chapter6_3/MCTargetDesc/Cpu0BaseInfo.h	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/MCTargetDesc/Cpu0BaseInfo.h	2013-09-12 16:56:38.385586066 +0800
@@ -147,6 +147,10 @@
     return 14;
   case Cpu0::PC:
     return 15;
+  case Cpu0::HI:
+    return 18;
+  case Cpu0::LO:
+    return 19;
   default: llvm_unreachable("Unknown register number!");
   }
 }
diff -Naur Chapter6_3/MCTargetDesc/Cpu0MCCodeEmitter.cpp Chapter7_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp
--- Chapter6_3/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2013-09-12 16:56:38.365586066 +0800
+++ Chapter7_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2013-09-12 16:56:38.385586066 +0800
@@ -69,10 +69,18 @@
 
   void EncodeInstruction(const MCInst &MI, raw_ostream &OS,
                          SmallVectorImpl<MCFixup> &Fixups) const;
+
   // getBinaryCodeForInstr - TableGen'erated function for getting the
   // binary encoding for an instruction.
   uint64_t getBinaryCodeForInstr(const MCInst &MI,
                                  SmallVectorImpl<MCFixup> &Fixups) const;
+
+  // getBranchTargetOpValue - Return binary encoding of the branch
+  // target operand, such as JMP #BB01, JEQ, JSUB. If the machine operand
+  // requires relocation, record the relocation and return zero.
+  unsigned getBranchTargetOpValue(const MCInst &MI, unsigned OpNo,
+                                  SmallVectorImpl<MCFixup> &Fixups) const;
+
    // getMachineOpValue - Return binary encoding of operand. If the machin
    // operand requires relocation, record the relocation and return zero.
   unsigned getMachineOpValue(const MCInst &MI,const MCOperand &MO,
@@ -128,6 +136,22 @@
   EmitInstruction(Binary, Size, OS);
 }
 
+/// getBranchTargetOpValue - Return binary encoding of the branch
+/// target operand. If the machine operand requires relocation,
+/// record the relocation and return zero.
+unsigned Cpu0MCCodeEmitter::
+getBranchTargetOpValue(const MCInst &MI, unsigned OpNo,
+                       SmallVectorImpl<MCFixup> &Fixups) const {
+
+  const MCOperand &MO = MI.getOperand(OpNo);
+  assert(MO.isExpr() && "getBranchTargetOpValue expects only expressions");
+
+  const MCExpr *Expr = MO.getExpr();
+  Fixups.push_back(MCFixup::Create(0, Expr,
+                                   MCFixupKind(Cpu0::fixup_Cpu0_PC24)));
+  return 0;
+}
+
 /// getMachineOpValue - Return binary encoding of operand. If the machine
 /// operand requires relocation, record the relocation and return zero.
 unsigned Cpu0MCCodeEmitter::
