diff -Naur Chapter6_2/Cpu0InstrInfo.td Chapter6_3/Cpu0InstrInfo.td
--- Chapter6_2/Cpu0InstrInfo.td	2013-09-12 16:56:38.373586066 +0800
+++ Chapter6_3/Cpu0InstrInfo.td	2013-09-12 16:56:38.365586066 +0800
@@ -133,7 +133,11 @@
 }]>;
 
 // Load/Store PatFrags.
+def sextloadi16_a   : AlignedLoad<sextloadi16>;
+def zextloadi16_a   : AlignedLoad<zextloadi16>;
+def extloadi16_a    : AlignedLoad<extloadi16>;
 def load_a          : AlignedLoad<load>;
+def truncstorei16_a : AlignedStore<truncstorei16>;
 def store_a         : AlignedStore<store>;
 
 //===----------------------------------------------------------------------===//
@@ -304,6 +308,12 @@
 ///  aligned
 defm LD     : LoadM32<0x01,  "ld",  load_a>;
 defm ST     : StoreM32<0x02, "st",  store_a>;
+defm LB     : LoadM32<0x03, "lb",  sextloadi8>;
+defm LBu    : LoadM32<0x04, "lbu", zextloadi8>;
+defm SB     : StoreM32<0x05, "sb", truncstorei8>;
+defm LH     : LoadM32<0x06, "lh",  sextloadi16_a>;
+defm LHu    : LoadM32<0x07, "lhu", zextloadi16_a>;
+defm SH     : StoreM32<0x08, "sh", truncstorei16_a>;
 
 /// Arithmetic Instructions (ALU Immediate)
 // IR "add" defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
@@ -395,6 +405,10 @@
 // 1: in == 0; 0: in != 0
           (XORi CPURegs:$in, 1)>;
 
+def : Pat<(i32 (extloadi1  addr:$src)), (LBu addr:$src)>;
+def : Pat<(i32 (extloadi8  addr:$src)), (LBu addr:$src)>;
+def : Pat<(i32 (extloadi16_a addr:$src)), (LHu addr:$src)>;
+
 // Sign Extend in Register. 
 // Get the least 7bits from register $in and signed bit (the 31th bit) from the 
 // 8th bit of register $in.
diff -Naur Chapter6_2/Cpu0ISelLowering.cpp Chapter6_3/Cpu0ISelLowering.cpp
--- Chapter6_2/Cpu0ISelLowering.cpp	2013-09-12 16:56:38.373586066 +0800
+++ Chapter6_3/Cpu0ISelLowering.cpp	2013-09-12 16:56:38.365586066 +0800
@@ -122,6 +122,16 @@
   // Set up the register classes
   addRegisterClass(MVT::i32, &Cpu0::CPURegsRegClass);
 
+  // Cpu0 does not have i1 type, so use i32 for
+  // setcc operations results (slt, sgt, ...).
+  setBooleanContents(ZeroOrOneBooleanContent);
+  setBooleanVectorContents(ZeroOrNegativeOneBooleanContent);
+
+  // Load extented operations for i1 types must be promoted
+  setLoadExtAction(ISD::EXTLOAD,  MVT::i1,  Promote);
+  setLoadExtAction(ISD::ZEXTLOAD, MVT::i1,  Promote);
+  setLoadExtAction(ISD::SEXTLOAD, MVT::i1,  Promote);
+
   // Cpu0 Custom Operations
   setOperationAction(ISD::GlobalAddress,      MVT::i32,   Custom);
 
