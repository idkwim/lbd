format 74
"Cpu0" // Cpu0::Cpu0
  revision 1
  modified_by 12 "cschen"
  // class settings
  //class diagram settings
  draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
  //use case diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default class_drawing_mode default shadow default show_stereotype_properties default
  //sequence diagram settings
  show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
  //collaboration diagram settings
  show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
  //object diagram settings
   write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
  //component diagram settings
  package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //deployment diagram settings
  package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
  draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
  //state diagram settings
  package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
  show_activities default region_horizontally default drawing_language default show_stereotype_properties default
  //activity diagram settings
  package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
  show_infonote default drawing_language default show_stereotype_properties default
  
  cpp_h_dir "/home/cschen/test/uml/r2/ELF/Cpu0/"
  cpp_src_dir "/home/cschen/test/uml/r2/ELF/Cpu0/"
  classview 128396 "Cpu0"
    //class diagram settings
    draw_all_relations default hide_attributes default hide_operations default hide_getset_operations default show_members_full_definition default show_members_visibility default show_members_stereotype default show_members_context default show_members_multiplicity default show_members_initialization default show_attribute_modifiers default member_max_width 0 show_parameter_dir default show_parameter_name default package_name_in_tab default class_drawing_mode default drawing_language default show_context_mode default auto_label_position default show_relation_modifiers default show_relation_visibility default show_infonote default shadow default show_stereotype_properties default
    //collaboration diagram settings
    show_full_operations_definition default show_hierarchical_rank default write_horizontally default drawing_language default package_name_in_tab default show_context default show_msg_context default draw_all_relations default shadow default show_stereotype_properties default
    //object diagram settings
     write_horizontally default package_name_in_tab default show_context default auto_label_position default draw_all_relations default shadow default show_stereotype_properties default
    //sequence diagram settings
    show_full_operations_definition default write_horizontally default class_drawing_mode default drawing_language default draw_all_relations default shadow default show_stereotype_properties default show_class_context_mode default show_msg_context_mode default
    //state diagram settings
    package_name_in_tab default show_context default auto_label_position default write_trans_label_horizontally default show_trans_definition default draw_all_relations default shadow default
    show_activities default region_horizontally default drawing_language default show_stereotype_properties default
    //class settings
    //activity diagram settings
    package_name_in_tab default show_context default show_opaque_action_definition default auto_label_position default write_flow_label_horizontally default draw_all_relations default shadow default
    show_infonote default drawing_language default show_stereotype_properties default
    class 131084 "anonymous1"
      visibility package stereotype "enum"
      cpp_decl "${comment}enum  {
${items}
};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ \\brief cpu0 internal references."
      attribute 136076 "LLD_R_CPU0_GOTRELINDEX"
	public type class_ref 131084 // anonymous1
	init_value " 1024"
	cpp_decl "  ${name}${value},${comment}"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 132748 "Cpu0BootAtom"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ boot record"
      classrelation 131596 // <generalisation>
	relation 131596 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 131596 // <generalisation>
	  b parent class_ref 130188 // PLT0Atom
      end

      operation 161036 "Cpu0BootAtom"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param in name "f" explicit_type "File"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw} : PLT0Atom(f) {
#ifndef NDEBUG
    _name = \".PLT0\";
#endif
  };
"
	
	
	
	
      end

      operation 161164 "rawContent"
	const cpp_virtual cpp_inline public explicit_return_type "ArrayRef<uint8_t>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    return ArrayRef<uint8_t>(cpu0BootAtomContent, 16);
  };
"
	
	
	
	
      end
    end

    class 132876 "Cpu0GOTAtom"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ \\brief Atoms that are used by Cpu0 dynamic linking"
      classrelation 131724 // <generalisation>
	relation 131724 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 131724 // <generalisation>
	  b parent class_ref 129804 // GOTAtom
      end

      operation 161292 "Cpu0GOTAtom"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param in name "f" explicit_type "File"
	  param in name "secName" explicit_type "StringRef"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw} : GOTAtom(f, secName) {};
"
	
	
	
	
      end

      operation 161420 "rawContent"
	const cpp_virtual cpp_inline public explicit_return_type "ArrayRef<uint8_t>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    return ArrayRef<uint8_t>(cpu0GotAtomContent, 16);
  };
"
	
	
	
	
      end
    end

    class 133004 "Cpu0PLT0Atom"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 131852 // <generalisation>
	relation 131852 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 131852 // <generalisation>
	  b parent class_ref 130188 // PLT0Atom
      end

      operation 161548 "Cpu0PLT0Atom"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param in name "f" explicit_type "File"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw} : PLT0Atom(f) {
#ifndef NDEBUG
    _name = \".PLT0\";
#endif
  };
"
	
	
	
	
      end

      operation 161676 "rawContent"
	const cpp_virtual cpp_inline public explicit_return_type "ArrayRef<uint8_t>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    return ArrayRef<uint8_t>(cpu0Plt0AtomContent, 16);
  };
"
	
	
	
	
      end
    end

    class 133132 "Cpu0PLTAtom"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 131980 // <generalisation>
	relation 131980 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 131980 // <generalisation>
	  b parent class_ref 130060 // PLTAtom
      end

      operation 161804 "Cpu0PLTAtom"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param in name "f" explicit_type "File"
	  param in name "secName" explicit_type "StringRef"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw} : PLTAtom(f, secName) {};
"
	
	
	
	
      end

      operation 161932 "rawContent"
	const cpp_virtual cpp_inline public explicit_return_type "ArrayRef<uint8_t>"
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    return ArrayRef<uint8_t>(cpu0PltAtomContent, 16);
  };
"
	
	
	
	
      end
    end

    class 133260 "ELFPassFile"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 132108 // <generalisation>
	relation 132108 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 132108 // <generalisation>
	  b parent class_ref 133388 // typedef10
      end

      operation 162060 "ELFPassFile"
	cpp_inline public explicit_return_type ""
	nparams 1
	  param in name "eti" type class_ref 130956 // ELFLinkingContext
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}${)}${volatile}${throw} : SimpleFile(eti, \"ELFPassFile\") {};
"
	
	
	
	
      end

      attribute 139404 "_alloc"
	public explicit_type "llvm::BumpPtrAllocator"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 133388 "typedef10"
      visibility package stereotype "typedef" explicit_base_type "SimpleFile"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 133516 "GOTPLTPass"
      visibility package 
      nformals 1
      formal name "Derived" type "class" explicit_default_value ""
        explicit_extends ""
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ \\brief Create GOT and PLT entries for relocations. Handles standard GOT/PLT
/ along with IFUNC and TLS."
      classrelation 132236 // <generalisation>
	relation 132236 ---|>
	  a public
	    cpp default "${type}"
	    classrelation_ref 132236 // <generalisation>
	  b parent class_ref 133644 // typedef11
      end

      operation 162188 "handleReference"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param in name "atom" explicit_type "DefinedAtom"
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    switch (ref.kind()) {

    case R_CPU0_CALL16:
      static_cast<Derived *>(this)->handlePLT32(ref);
      break;

    case R_CPU0_PC24:
      static_cast<Derived *>(this)->handlePC24(ref);
      break;
#if 0
    case R_CPU0_GOTTPOFF: // GOT Thread Pointer Offset
      static_cast<Derived *>(this)->handleGOTTPOFF(ref);
      break;
    case R_CPU0_GOTPCREL:
      static_cast<Derived *>(this)->handleGOTPCREL(ref);
      break;
#endif
    }
  };
"
	
	
	
	
	comment "/ \\brief Handle a specific reference."
      end

      operation 162316 "getIFUNCPLTEntry"
	cpp_inline protected return_type class_ref 130060 // PLTAtom
	nparams 1
	  param in name "da" explicit_type "DefinedAtom"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    auto plt = _pltMap.find(da);
    if (plt != _pltMap.end())
      return plt->second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, \".got.plt\");
    ga->addReference(R_CPU0_RELGOT, 0, da, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, \".plt\");
    pa->addReference(R_CPU0_PC24, 2, ga, -4);
#ifndef NDEBUG
    ga->_name = \"__got_ifunc_\";
    ga->_name += da->name();
    pa->_name = \"__plt_ifunc_\";
    pa->_name += da->name();
#endif
    _gotMap[da] = ga;
    _pltMap[da] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  };
"
	
	
	
	
	comment "/ \\brief get the PLT entry for a given IFUNC Atom.
/
/ If the entry does not exist. Both the GOT and PLT entry is created."
      end

      operation 162444 "handleIFUNC"
	cpp_inline protected explicit_return_type "ErrorOr<void>"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    auto target = dyn_cast_or_null<const DefinedAtom>(ref.target());
#ifdef DYNLINKER
    if (target && target->contentType() == DefinedAtom::typeResolver)
      const_cast<Reference &>(ref).setTarget(getIFUNCPLTEntry(target));
#endif // DYNLINKER
    return error_code::success();
  };
"
	
	
	
	
	comment "/ \\brief Redirect the call to the PLT stub for the target IFUNC.
/
/ This create a PLT and GOT entry for the IFUNC if one does not exist. The
/ GOT entry and a RELGOT relocation to the original target resolver."
      end

      operation 162572 "getGOTTPOFF"
	cpp_inline protected return_type class_ref 129804 // GOTAtom
	nparams 1
	  param in name "atom" explicit_type "Atom"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    auto got = _gotMap.find(atom);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, \".got\");
      g->addReference(R_CPU0_TLS_TPREL32, 0, atom, 0);
#ifndef NDEBUG
      g->_name = \"__got_tls_\";
      g->_name += atom->name();
#endif
      _gotMap[atom] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got->second;
  };
"
	
	
	
	
	comment "/ \\brief Create a GOT entry for the TP offset of a TLS atom."
      end

      operation 162700 "handleGOTTPOFF"
	cpp_inline protected explicit_return_type "void"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    const_cast<Reference &>(ref).setTarget(getGOTTPOFF(ref.target()));
    const_cast<Reference &>(ref).setKind(R_CPU0_PC24);
  };
"
	
	
	
	
	comment "/ \\brief Create a TLS_TPREL32 GOT entry and change the relocation to a PC24 to
/ the GOT."
      end

      operation 162828 "getNullGOT"
	cpp_inline protected return_type class_ref 129804 // GOTAtom
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    if (!_null) {
      _null = new (_file._alloc) Cpu0GOTAtom(_file, \".got.plt\");
#ifndef NDEBUG
      _null->_name = \"__got_null\";
#endif
    }
    return _null;
  };
"
	
	
	
	
	comment "/ \\brief Create a GOT entry containing 0."
      end

      operation 162956 "getGOT"
	cpp_inline protected return_type class_ref 129804 // GOTAtom
	nparams 1
	  param in name "da" explicit_type "DefinedAtom"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    auto got = _gotMap.find(da);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, \".got\");
      g->addReference(R_CPU0_32, 0, da, 0);
#ifndef NDEBUG
      g->_name = \"__got_\";
      g->_name += da->name();
#endif
      _gotMap[da] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got->second;
  };
"
	
	
	
	
      end

      operation 163084 "handleGOTPCREL"
	cpp_inline protected explicit_return_type "void"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    const_cast<Reference &>(ref).setKind(R_CPU0_PC24);
    if (isa<UndefinedAtom>(ref.target()))
      const_cast<Reference &>(ref).setTarget(getNullGOT());
    else if (const DefinedAtom *da = dyn_cast<const DefinedAtom>(ref.target()))
      const_cast<Reference &>(ref).setTarget(getGOT(da));
  };
"
	
	
	
	
	comment "/ \\brief Handle a GOTPCREL relocation to an undefined weak atom by using a
/ null GOT entry."
      end

      operation 163212 "GOTPLTPass"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param in name "ti" type class_ref 130956 // ELFLinkingContext
	  param in name "isExe" explicit_type "bool"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw} : _file(ti), _null(nullptr), _PLT0(nullptr), _got0(nullptr)/*,
        _got1(nullptr)*/, _boot(new Cpu0BootAtom(_file)), _isStaticExe(isExe) 
       { };
"
	
	
	
	
      end

      operation 163340 "perform"
	cpp_virtual cpp_inline public explicit_return_type "void"
	nparams 1
	  param inout name "mf" explicit_type "MutableFile"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    ScopedTask task(getDefaultDomain(), \"Cpu0 GOT/PLT Pass\");
    // Process all references.
    for (const auto &atom : mf.defined())
      for (const auto &ref : *atom)
        handleReference(*atom, *ref);

    // Add all created atoms to the link.
    uint64_t ordinal = 0;
    if (_isStaticExe) {
      MutableFile::DefinedAtomRange atomRange = mf.definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it < atomRange.end(); it++) {
        if ((*it)->name() == \"_Z5startv\") {
          find = true;
          break;
        }
      }
      assert(find && \"not found _Z5startv\\n\");
      _boot->addReference(R_CPU0_PC24, 0, *it, -3);
      _boot->setOrdinal(ordinal++);
      mf.addAtom(*_boot);
    }
#ifdef DYNLINKER
    if (_PLT0) {
      MutableFile::DefinedAtomRange atomRange = mf.definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it < atomRange.end(); it++) {
        if ((*it)->name() == \"_Z14dynamic_linkerv\") {
          find = true;
          break;
        }
      }
      assert(find && \"Cannot find _Z14dynamic_linkerv()\");
      _PLT0->addReference(R_CPU0_PC24, 12, *it, -3);
      _PLT0->setOrdinal(ordinal++);
      mf.addAtom(*_PLT0);
    }
    for (auto &plt : _pltVector) {
      plt->setOrdinal(ordinal++);
      mf.addAtom(*plt);
    }
    if (_null) {
      _null->setOrdinal(ordinal++);
      mf.addAtom(*_null);
    }
    if (_PLT0) {
      _got0->setOrdinal(ordinal++);
      mf.addAtom(*_got0);
    }
    for (auto &got : _gotVector) {
      got->setOrdinal(ordinal++);
      mf.addAtom(*got);
    }
#endif // DYNLINKER
  };
"
	
	
	
	
	comment "/ \\brief Do the pass.
/
/ The goal here is to first process each reference individually. Each call
/ to handleReference may modify the reference itself and/or create new
/ atoms which must be stored in one of the maps below.
/
/ After all references are handled, the atoms created during that are all
/ added to mf."
      end

      classrelation 132364 // _file (<directional composition>)
	relation 132364 *-->
	  a role_name "_file" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 132364 // _file (<directional composition>)
	  b parent class_ref 133260 // ELFPassFile
      end

      classrelation 132492 // _gotMap (<unidirectional association>)
	relation 132492 --->
	  stereotype "llvm::DenseMap"
	  a role_name "_gotMap" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<const Atom*,${type}*> ${name}${value};
"
	    classrelation_ref 132492 // _gotMap (<unidirectional association>)
	  b parent class_ref 129804 // GOTAtom
      end

      classrelation 132620 // _pltMap (<unidirectional association>)
	relation 132620 --->
	  stereotype "llvm::DenseMap"
	  a role_name "_pltMap" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<const Atom*,${type}*> ${name}${value};
"
	    classrelation_ref 132620 // _pltMap (<unidirectional association>)
	  b parent class_ref 130060 // PLTAtom
      end

      classrelation 132748 // _gotVector (<unidirectional association>)
	relation 132748 --->
	  stereotype "std::vector"
	  a role_name "_gotVector" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}*> ${name}${value};
"
	    classrelation_ref 132748 // _gotVector (<unidirectional association>)
	  b parent class_ref 129804 // GOTAtom
      end

      classrelation 132876 // _pltVector (<unidirectional association>)
	relation 132876 --->
	  stereotype "std::vector"
	  a role_name "_pltVector" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${stereotype}<${type}*> ${name}${value};
"
	    classrelation_ref 132876 // _pltVector (<unidirectional association>)
	  b parent class_ref 130060 // PLTAtom
      end

      classrelation 133004 // _boot (<unidirectional association>)
	relation 133004 --->
	  a role_name "_boot" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 133004 // _boot (<unidirectional association>)
	  b parent class_ref 130188 // PLT0Atom
      end

      classrelation 133132 // _null (<unidirectional association>)
	relation 133132 --->
	  a role_name "_null" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 133132 // _null (<unidirectional association>)
	  b parent class_ref 129804 // GOTAtom
      end

      classrelation 133260 // _PLT0 (<unidirectional association>)
	relation 133260 --->
	  a role_name "_PLT0" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 133260 // _PLT0 (<unidirectional association>)
	  b parent class_ref 130188 // PLT0Atom
      end

      classrelation 133388 // _got0 (<unidirectional association>)
	relation 133388 --->
	  a role_name "_got0" protected
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} * ${name}${value};
"
	    classrelation_ref 133388 // _got0 (<unidirectional association>)
	  b parent class_ref 129804 // GOTAtom
      end

      attribute 139532 "_isStaticExe"
	public explicit_type "bool"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end
    end

    class 133644 "typedef11"
      visibility package stereotype "typedef" explicit_base_type "Pass"
      cpp_decl "${comment}typedef ${type} ${name};
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
    end

    class 133772 "StaticGOTPLTPass"
      visibility package 
      nactuals 1
      actual class class_ref 133516 // GOTPLTPass
        rank 0 value class_ref 133772 // StaticGOTPLTPass
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      comment "/ @}
/ This implements the static relocation model. Meaning GOT and PLT entries are
/ not created for references that can be directly resolved. These are
/ converted to a direct relocation. For entries that do require a GOT or PLT
/ entry, that entry is statically bound.
/
/ TLS always assumes module 1 and attempts to remove indirection."
      classrelation 133516 // <realization>
	relation 133516 -_-|>
	  stereotype "bind"
	  a public
	    cpp default "${type}"
	    classrelation_ref 133516 // <realization>
	  b parent class_ref 133516 // GOTPLTPass
      end

      operation 163468 "StaticGOTPLTPass"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param in name "ti" type class_ref 131212 // Cpu0LinkingContext
	  param in name "isExe" explicit_type "bool"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw} : GOTPLTPass(ti, isExe) { };
"
	
	
	
	
      end

      operation 163596 "handlePLT32"
	cpp_inline public explicit_return_type "ErrorOr<void>"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    // __tls_get_addr is handled elsewhere.
    if (ref.target() && ref.target()->name() == \"__tls_get_addr\") {
      const_cast<Reference &>(ref).setKind(R_CPU0_NONE);
      return error_code::success();
    } else
      // Static code doesn't need PLTs.
      const_cast<Reference &>(ref).setKind(R_CPU0_PC24);
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null<const DefinedAtom>(ref.target()))
      if (da->contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    return error_code::success();
  };
"
	
	
	
	
      end

      operation 163724 "handlePC24"
	cpp_inline public explicit_return_type "ErrorOr<void>"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} { return handleIFUNC(ref); };
"
	
	
	
	
      end
    end

    class 133900 "DynamicGOTPLTPass"
      visibility package 
      nactuals 1
      actual class class_ref 133516 // GOTPLTPass
        rank 0 value class_ref 133900 // DynamicGOTPLTPass
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      classrelation 133644 // <realization>
	relation 133644 -_-|>
	  stereotype "bind"
	  a public
	    cpp default "${type}"
	    classrelation_ref 133644 // <realization>
	  b parent class_ref 133516 // GOTPLTPass
      end

      operation 163852 "DynamicGOTPLTPass"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param in name "ti" type class_ref 131212 // Cpu0LinkingContext
	  param in name "isExe" explicit_type "bool"
	cpp_decl "    ${comment}${inline}${name}${(}const ${t0} & ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw} : GOTPLTPass(ti, isExe) { };
"
	
	
	
	
      end

      operation 163980 "getPLT0"
	cpp_inline public return_type class_ref 130188 // PLT0Atom
	nparams 0
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}${)}${const}${volatile}${throw}${abstract} {
    if (_PLT0)
      return _PLT0;
    // Fill in the null entry.
    getNullGOT();
    _PLT0 = new (_file._alloc) Cpu0PLT0Atom(_file);
    _got0 = new (_file._alloc) Cpu0GOTAtom(_file, \".got.plt\");
#if 0
    _PLT0->addReference(R_CPU0_GOT16, 0, _got0, -2); // debug
#endif
#ifndef NDEBUG
    _got0->_name = \"__got0\";
#endif
    return _PLT0;
  };
"
	
	
	
	
      end

      operation 164108 "getPLTEntry"
	cpp_inline public return_type class_ref 130060 // PLTAtom
	nparams 1
	  param in name "a" explicit_type "Atom"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    auto plt = _pltMap.find(a);
    if (plt != _pltMap.end())
      return plt->second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, \".got.plt\");
    ga->addReference(R_CPU0_JUMP_SLOT, 0, a, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, \".plt\");
    getPLT0();  // add _PLT0 and _got0
    pa->addReference(LLD_R_CPU0_GOTRELINDEX, 0, ga, -2);
    // Set the starting address of the got entry to the second instruction in
    // the plt entry.
    ga->addReference(R_CPU0_32, 0, pa, 4);
#ifndef NDEBUG
    ga->_name = \"__got_\";
    ga->_name += a->name();
    pa->_name = \"__plt_\";
    pa->_name += a->name();
#endif
    _gotMap[a] = ga;
    _pltMap[a] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  };
"
	
	
	
	
      end

      operation 164236 "handlePLT32"
	cpp_inline public explicit_return_type "ErrorOr<void>"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    // Turn this into a CALL24 to the PLT entry.
    // const_cast<Reference &>(ref).setKind(R_CPU0_CALL24);
    // Handle IFUNC.
    if (const DefinedAtom *da = 
            dyn_cast_or_null<const DefinedAtom>(ref.target()))
      if (da->contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    if (isa<const SharedLibraryAtom>(ref.target())) {
      const_cast<Reference &>(ref).setTarget(getPLTEntry(ref.target()));
      // Turn this into a PC24 to the PLT entry.
    #if 1
      const_cast<Reference &>(ref).setKind(R_CPU0_PC24);
    #endif
    }
    return error_code::success();
  };
"
	
	
	
	
      end

      operation 164364 "handlePC24"
	cpp_inline public explicit_return_type "ErrorOr<void>"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    if (ref.target() && isa<SharedLibraryAtom>(ref.target()))
      return handlePLT32(ref);
    return handleIFUNC(ref);
  };
"
	
	
	
	
      end

      operation 164492 "getSharedGOT"
	cpp_inline public return_type class_ref 129804 // GOTAtom
	nparams 1
	  param in name "sla" explicit_type "SharedLibraryAtom"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}const ${type} * ${name}${(}const ${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    auto got = _gotMap.find(sla);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, \".got.dyn\");
      g->addReference(R_CPU0_GLOB_DAT, 0, sla, 0);
#ifndef NDEBUG
      g->_name = \"__got_\";
      g->_name += sla->name();
#endif
      _gotMap[sla] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got->second;
  };
"
	
	
	
	
      end

      operation 164620 "handleGOTPCREL"
	cpp_inline public explicit_return_type "void"
	nparams 1
	  param in name "ref" explicit_type "Reference"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    const_cast<Reference &>(ref).setKind(R_CPU0_PC24);
    if (isa<UndefinedAtom>(ref.target()))
      const_cast<Reference &>(ref).setTarget(getNullGOT());
    else if (const DefinedAtom *da = dyn_cast<const DefinedAtom>(ref.target()))
      const_cast<Reference &>(ref).setTarget(getGOT(da));
    else if (const auto sla = dyn_cast<const SharedLibraryAtom>(ref.target()))
      const_cast<Reference &>(ref).setTarget(getSharedGOT(sla));
  };
"
	
	
	
	
      end
    end

    class 134028 "Cpu0SoPlt"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      attribute 139660 "funAddr"
	public explicit_type "uint32_t"
	multiplicity "[100]"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${multiplicity}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 139788 "funAddrSize"
	public explicit_type "int"
	init_value "=  0"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${h_value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      class 134156 "dynsym"
	visibility package stereotype "struct"
	cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	attribute 139916 "stridx"
	  public explicit_type "uint32_t"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end
      end

      classrelation 133772 // Dynsym (<directional composition>)
	relation 133772 *-->
	  a role_name "Dynsym" multiplicity "[100]" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${multiplicity}${value};
"
	    classrelation_ref 133772 // Dynsym (<directional composition>)
	  b parent class_ref 134156 // dynsym
      end

      attribute 140044 "DynsymSize"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 140172 "Dynstr"
	public explicit_type "uint8_t"
	multiplicity "[1000]"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${multiplicity}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 140300 "DynstrSize"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 164748 "create"
	cpp_inline public explicit_return_type "int"
	nparams 1
	  param inout name "o" explicit_type "ObjectFile"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    error_code ec;
    for (section_iterator si = o->begin_sections(),
                          se = o->end_sections();
                          si != se; si.increment(ec)) {
      if (ec) return 1;
      StringRef Name;
      StringRef Contents;
      uint64_t BaseAddr;
      if (error(si->getName(Name))) continue;
      if (error(si->getContents(Contents))) continue;
      if (error(si->getAddress(BaseAddr))) continue;
      if (Name == \".dynsym\") {
        // Dump out the content as hex and printable ascii characters.
        for (std::size_t addr = 0, end = Contents.size(); addr < end; addr += 16) {
          Dynsym[DynsymSize].stridx = *reinterpret_cast<llvm::support::ubig32_t*>((uint32_t*)(Contents.begin()+addr));
        }
      }
      if (Name == \".dynstr\") {
        memcpy(Dynstr, Contents.begin(), Contents.size());
        DynstrSize = Contents.size();
      }
    }

    return 0;
  };
"
	
	
	
	
      end

      operation 164876 "getDynsymEntryIdxByTargetAddr"
	cpp_inline public explicit_return_type "int"
	nparams 3
	  param in name "fAddr" explicit_type "uint64_t"
	  param inout name "funAddr" explicit_type "uint32_t"
	  param in name "funAddrSize" explicit_type "int"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}, ${t1} * ${p1}${v1}, ${t2} ${p2}${v2}${)}${const}${volatile}${throw}${abstract} {
    for (int i = 0; i < funAddrSize; i++) {
      if (fAddr == funAddr[i]) {
        return i;
      }
    }
    return -1;
  };
"
	
	
	
	
	comment " Return dynsym entry number"
      end

      operation 165004 "getDynsymIdxByName"
	cpp_inline public explicit_return_type "int"
	nparams 1
	  param inout name "name" explicit_type "uint8_t"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} * ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
    for (int idx = 1, i = 1; i < DynstrSize; idx++) {
      if (strcmp((char*)name, (char*)Dynstr+i) == 0) {
        return idx;
      }
      i = i + strlen((char*)(Dynstr+i)) + 1;
    }
    return 0;
  };
"
	
	
	
	
	comment " 0: fail to find index by name
 > 0: get the dynsym index"
      end
    end

    class 134284 "Cpu0ExePlt"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      
      class 134412 "dynsym"
	visibility package stereotype "struct"
	cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
	java_decl ""
	php_decl ""
	python_2_2 python_decl ""
	idl_decl ""
	explicit_switch_type ""
	
	attribute 140428 "stridx"
	  public explicit_type "uint32_t"
	  cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	  java_decl ""
	  php_decl ""
	  python_decl ""
	  idl_decl ""
	end
      end

      classrelation 133900 // Dynsym (<directional composition>)
	relation 133900 *-->
	  a role_name "Dynsym" multiplicity "[100]" public
	    cpp default "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${multiplicity}${value};
"
	    classrelation_ref 133900 // Dynsym (<directional composition>)
	  b parent class_ref 134412 // dynsym
      end

      attribute 140556 "DynsymSize"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 140684 "Dynstr"
	public explicit_type "uint8_t"
	multiplicity "[1000]"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${multiplicity}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      attribute 140812 "DynstrSize"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
      end

      operation 165132 "create"
	cpp_inline public explicit_return_type "int"
	nparams 2
	  param in name "context" explicit_type "Cpu0LinkingContext"
	  param inout name "buf" explicit_type "llvm::FileOutputBuffer"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
    auto dynsymSection = context.getTargetHandler<Cpu0ELFType>().targetLayout().findOutputSection(\".dynsym\");
    uint64_t dynsymFileOffset, dynsymSizeOfBytes;
    if (dynsymSection) {
      dynsymFileOffset = dynsymSection->fileOffset();
      dynsymSizeOfBytes = dynsymSection->memSize();
      uint8_t *atomContent = buf.getBufferStart() + dynsymFileOffset;
      for (uint64_t i = 0; i < dynsymSizeOfBytes; i += 16) {
        Dynsym[DynsymSize].stridx = *reinterpret_cast<llvm::support::ubig32_t*>((uint32_t*)(atomContent + i));
        DynsymSize++;
      }
    }
    else
      return 1;
    auto dynstrSection = context.getTargetHandler<Cpu0ELFType>().targetLayout().findOutputSection(\".dynstr\");
    uint64_t dynstrFileOffset, dynstrSize;
    if (dynstrSection) {
      dynstrFileOffset = dynstrSection->fileOffset();
      dynstrSize = dynstrSection->memSize();
      uint8_t *atomContent = buf.getBufferStart() + dynstrFileOffset;
      memcpy(Dynstr, atomContent, dynstrSize);
      DynstrSize = dynstrSize;
    }
    else
      return 1;

    return 0;
  };
"
	
	
	
	
      end
    end
  end

  deploymentview 128268 "Cpu0"
    //deployment diagram settings
    package_name_in_tab default show_context default write_horizontally default auto_label_position default draw_all_relations default shadow default
    draw_component_as_icon default show_component_req_prov default show_component_rea default show_stereotype_properties default
    artifact 128396 "Cpu0LinkingContext"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 131084 // anonymous1
      end
    end

    artifact 129292 "Cpu0BootAtom"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 132748 // Cpu0BootAtom
      end
    end

    artifact 129420 "Cpu0GOTAtom"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 132876 // Cpu0GOTAtom
      end
    end

    artifact 129548 "Cpu0PLT0Atom"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133004 // Cpu0PLT0Atom
      end
    end

    artifact 129676 "Cpu0PLTAtom"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133132 // Cpu0PLTAtom
      end
    end

    artifact 129804 "typedef10"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133388 // typedef10
      end
    end

    artifact 129932 "ELFPassFile"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133260 // ELFPassFile
      end
    end

    artifact 130060 "typedef11"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133644 // typedef11
      end
    end

    artifact 130188 "GOTPLTPass"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133516 // GOTPLTPass
      end
    end

    artifact 130316 "StaticGOTPLTPass"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133772 // StaticGOTPLTPass
      end
    end

    artifact 130444 "DynamicGOTPLTPass"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 133900 // DynamicGOTPLTPass
      end
    end

    artifact 130572 "Cpu0SoPlt"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 134028 // Cpu0SoPlt
      end
    end

    artifact 130700 "Cpu0ExePlt"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_classes
	class_ref 134284 // Cpu0ExePlt
      end
    end
  end
end
