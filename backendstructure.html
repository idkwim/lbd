

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Backend structure &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.3.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Arithmetic and logic lsupport" href="otherinst.html" />
    <link rel="prev" title="Cpu0 Instruction Set and LLVM Target Description" href="llvmstructure.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Backend structure</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Arithmetic and logic lsupport</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="backend-structure">
<span id="sec-backendstructure"></span><h1>Backend structure<a class="headerlink" href="#backend-structure" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduce the back end class inherit tree and class members first.
Next, following the back end structure, adding individual class implementation
in each section.
There are compiler knowledge like DAG (Directed-Acyclic-Graph) and instruction
selection needed in this chapter.
This chapter explains these knowledge just when needed.
At the end of this chapter, we will have a back end to compile llvm
intermediate code into cpu0 assembly code.</p>
<p>Many code are added in this chapter. They almost are common in every back end
except the back end name (cpu0 or mips ...). Actually, we copy almost all the
code from mips and replace the name with cpu0. Please focus on the classes
relationship in this backend structure. Once knowing the structure, you can
create your backend structure as quickly as we did, even though there are 3000
lines of code in this chapter.</p>
<div class="section" id="targetmachine-structure">
<h2>TargetMachine structure<a class="headerlink" href="#targetmachine-structure" title="Permalink to this headline">¶</a></h2>
<p>Your back end should define a TargetMachine class, for example, we define the
Cpu0TargetMachine class.
Cpu0TargetMachine class contains it&#8217;s own instruction class, frame/stack class,
DAG (Directed-Acyclic-Graph) class, and register class.
The Cpu0TargetMachine contents and it&#8217;s own class as follows,</p>
<p class="rubric">include/llvm/Target/TargetMachine.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- TargetMachine.h</span>
<span class="k">class</span> <span class="nc">TargetMachine</span> <span class="p">{</span>
  <span class="n">TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Interfaces to the major aspects of target machine information:</span>
  <span class="c1">// -- Instruction opcode and operand information</span>
  <span class="c1">// -- Pipelines and scheduling information</span>
  <span class="c1">// -- Stack frame information</span>
  <span class="c1">// -- Selection DAG lowering information</span>
  <span class="c1">//</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetInstrInfo</span>         <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetLowering</span>    <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetSelectionDAGInfo</span> <span class="o">*</span><span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span>             <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
  <span class="c1">/// getSubtarget - This method returns a pointer to the specified type of</span>
  <span class="c1">/// TargetSubtargetInfo.  In debug builds, it verifies that the object being</span>
  <span class="c1">/// returned is of the correct type.</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">STC</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">STC</span> <span class="o">&amp;</span><span class="n">getSubtarget</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">STC</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">getSubtargetImpl</span><span class="p">());</span>
  <span class="p">}</span>

<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">LLVMTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetMachine</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span> <span class="c1">// Can only create subclasses.</span>
  <span class="n">LLVMTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TargetTriple</span><span class="p">,</span>
          <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="n">TargetOptions</span> <span class="n">Options</span><span class="p">,</span>
          <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
          <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetObjectFile.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetObjectFile.cpp</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetMachine.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetMachine.cpp</p>
<p class="rubric">include/llvm/Target/TargetInstInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TargetInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCInstrInfo</span> <span class="p">{</span>
  <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">TargetInstrInfoImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfo</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">TargetInstrInfoImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">CallFrameSetupOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">CallFrameDestroyOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="n">CallFrameSetupOpcode</span><span class="p">,</span> <span class="n">CallFrameDestroyOpcode</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0.td</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0CallingConv.td</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0FrameLowering.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0InstrInfo.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0InstrInfo.cpp</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0ISelLowering.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0MachineFunction.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0SelectionDAGInfo.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0SelectionDAGInfo.cpp</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0Subtarget.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0Subtarget.cpp</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0RegisterInfo.h</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0RegisterInfo.cpp</p>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>

<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>
<span class="c1">//- Cpu0InstInfo.h</span>
<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="figure align-center" id="backendstructure-f1">
<img alt="_images/1.png" src="_images/1.png" />
<p class="caption">Figure 1: TargetMachine class diagram 1</p>
</div>
<p>The Cpu0TargetMachine inherit tree is TargetMachine &lt;- LLVMTargetMachine &lt;-
Cpu0TargetMachine.
Cpu0TargetMachine has class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering,
Cpu0TargetLowering and Cpu0SelectionDAGInfo.
Class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering, Cpu0TargetLowering and
Cpu0SelectionDAGInfo are inherited from parent class TargetSubtargetInfo,
TargetInstrInfo, TargetFrameLowering, TargetLowering and TargetSelectionDAGInfo.</p>
<p><a class="pageref" href="#backendstructure-f1">Figure  1</a> shows Cpu0TargetMachine inherit tree and it&#8217;s
Cpu0InstrInfo class inherit tree.
Cpu0TargetMachine contains Cpu0InstrInfo and ... other class.
Cpu0InstrInfo contains Cpu0RegisterInfo class, RI. Cpu0InstrInfo.td and
Cpu0RegisterInfo.td will generate Cpu0GenInstrInfo.inc and
Cpu0GenRegisterInfo.inc which contain some member functions implementation for
class Cpu0InstrInfo and Cpu0RegisterInfo.</p>
<p><a class="pageref" href="#backendstructure-f2">Figure  2</a> as below shows Cpu0TargetMachine contains
class
TSInfo: Cpu0SelectionDAGInfo, FrameLowering: Cpu0FrameLowering, Subtarget:
Cpu0Subtarget and TLInfo: Cpu0TargetLowering.</p>
<div class="figure align-center" id="backendstructure-f2">
<img alt="_images/2.png" src="_images/2.png" />
<p class="caption">Figure 2: TargetMachine class diagram 2</p>
</div>
<div class="figure align-center" id="backendstructure-f3">
<img alt="_images/3.png" src="_images/3.png" />
<p class="caption">Figure 3: TargetMachine members and operators</p>
</div>
<p><a class="pageref" href="#backendstructure-f3">Figure  3</a> shows some members and operators (member function)
of the parent class TargetMachine&#8217;s.
<a class="pageref" href="#backendstructure-f4">Figure  4</a> as below shows some members of class InstrInfo,
RegisterInfo and TargetLowering.
Class DAGInfo is skipped here.</p>
<div class="figure align-center" id="backendstructure-f4">
<img alt="_images/4.png" src="_images/4.png" />
<p class="caption">Figure 4: Other class members and operators</p>
</div>
<p>Benefit from the inherit tree structure, we just need to implement few code in
instruction, frame/stack, select DAG class.
Many code implemented by their parent class.
The llvm-tblgen generate Cpu0GenInstrInfo.inc from Cpu0InstrInfo.td.
Cpu0InstrInfo.h extract those code it need from Cpu0GenInstrInfo.inc by define
“#define GET_INSTRINFO_HEADER”.
Following is the code fragment from Cpu0GenInstrInfo.inc.
Code between “#if def  GET_INSTRINFO_HEADER” and “#endif // GET_INSTRINFO_HEADER”
will be extracted by Cpu0InstrInfo.h.</p>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>
</pre></div>
</div>
<p>Reference Write An LLVM Backend web site <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>Now, the code in Chapter3_1/ add class Cpu0TargetMachine(Cpu0TargetMachine.h and
cpp), Cpu0Subtarget (Cpu0Subtarget.h and .cpp), Cpu0InstrInfo (Cpu0InstrInfo.h
and .cpp), Cpu0FrameLowering (Cpu0FrameLowering.h and .cpp), Cpu0TargetLowering
(Cpu0ISelLowering.h and .cpp) and Cpu0SelectionDAGInfo ( Cpu0SelectionDAGInfo.h
and .cpp).
CMakeLists.txt  modified with those new added *.cpp as follows,</p>
<p class="rubric">lbdex/Chapter3_1/CMakeLists.txt</p>
<p>Please take a look for Chapter3_1 code.
After that, building Chapter3_1 by make as chapter 2 (of course, you should remove old
src/lib/Target/Cpu0 and replace them with src/lib/Target/Cpu0/lbdex/Chapter3_1/).
You can remove cmake_debug_build/lib/Target/Cpu0/*.inc before do “make” to ensure your code
rebuild completely.
By remove *.inc, all files those have included .inc will be rebuild, then your
Target library will be regenerated.
Command as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:cmake_debug_build Jonathan<span class="nv">$ </span>rm -rf lib/Target/Cpu0/*
</pre></div>
</div>
<p>Now, let&#8217;s build Chapter3_1 as the following command,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-75-57:ExampleCode Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/lib/Target/Cpu0/lbdex
118-165-75-57:lbdex Jonathan<span class="nv">$ </span>sh removecpu0.sh
118-165-75-57:lbdex Jonathan<span class="nv">$ </span>cp -rf Chapter3_1/
* ../.

118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
Assertion failed: <span class="o">(</span>AsmInfo <span class="o">&amp;&amp;</span> <span class="s2">&quot;MCAsmInfo not initialized.&quot;</span>
...
</pre></div>
</div>
<p>The errors say that we have not Target AsmPrinter.
Let&#8217;s add it in next section.</p>
</div>
<div class="section" id="add-asmprinter">
<h2>Add AsmPrinter<a class="headerlink" href="#add-asmprinter" title="Permalink to this headline">¶</a></h2>
<p>Chapter3_2/cpu0 contains the Cpu0AsmPrinter definition. First, we add definitions in
Cpu0.td to support AssemblyWriter.
Cpu0.td is added with the following fragment,</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0.td</p>
<p>As comments indicate, it will generate Cpu0GenAsmWrite.inc which is included
by Cpu0InstPrinter.cpp as follows,</p>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/Cpu0InstPrinter.h</p>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/Cpu0InstPrinter.cpp</p>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/CMakeLists.txt</p>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/LLVMBuild.txt</p>
<p>Cpu0GenAsmWrite.inc has the implementation of
Cpu0InstPrinter::printInstruction() and Cpu0InstPrinter::getRegisterName().
Both of these functions can be auto-generated from the information we defined
in Cpu0InstrInfo.td and Cpu0RegisterInfo.td.
To let these two functions work in our code, the only thing need to do is add a
class Cpu0InstPrinter and include them as did in Chapter3_1.</p>
<p>File Chapter3_1/Cpu0/InstPrinter/Cpu0InstPrinter.cpp include Cpu0GenAsmWrite.inc and
call the auto-generated functions from TableGen.</p>
<p>Next, add Cpu0MCInstLower (Cpu0MCInstLower.h, Cpu0MCInstLower.cpp), as well as
Cpu0BaseInfo.h,
Cpu0FixupKinds.h and Cpu0MCAsmInfo (Cpu0MCAsmInfo.h, Cpu0MCAsmInfo.cpp) in
sub-directory MCTargetDesc as follows,</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0MCInstLower.h</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0MCInstLower.cpp</p>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0BaseInfo.h</p>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCAsmInfo.h</p>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCAsmInfo.cpp</p>
<p>Finally, add code in Cpu0MCTargetDesc.cpp to register Cpu0InstPrinter as
follows,</p>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCTargetDesc.h</p>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0MCAsmInfo</span><span class="p">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0AsmPrinter</span>
</pre></div>
</div>
<p>Now, it&#8217;s time to work with AsmPrinter. According section
&#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id6" id="id2">[2]</a>, we can register our AsmPrinter when we need it
as the following function of LLVMInitializeCpu0AsmPrinter(),</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0AsmPrinter.h</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0AsmPrinter.cpp</p>
<p>The dynamic register mechanism is a good idea, right.</p>
<p>Add the following code to Cpu0ISelLowering.cpp.</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">Cpu0TargetObjectFile</span><span class="p">()),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>

  <span class="c1">// Set up the register classes</span>
  <span class="n">addRegisterClass</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">);</span>

<span class="c1">//- Set .align 2</span>
<span class="c1">// It will emit .align 2 later</span>
  <span class="n">setMinFunctionAlignment</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// must, computeRegisterProperties - Once all of the register classes are</span>
<span class="c1">//  added, this allows us to compute derived properties we expose.</span>
  <span class="n">computeRegisterProperties</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Add the following code to Cpu0MachineFunction.h since the Cpu0AsmPrinter.cpp
will call getEmitNOAT().</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">EmitNOAT</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="o">:</span> <span class="p">...</span>
    <span class="n">EmitNOAT</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span>
    <span class="p">...</span>
    <span class="p">{}</span>

  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">getEmitNOAT</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">EmitNOAT</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setEmitNOAT</span><span class="p">()</span> <span class="p">{</span> <span class="n">EmitNOAT</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Beyond add these new .cpp files to CMakeLists.txt, please remember to add
subdirectory InstPrinter, enable asmprinter, add libraries AsmPrinter and
Cpu0AsmPrinter to LLVMBuild.txt as follows,</p>
<p class="rubric">lbdex/Chapter3_2/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenMCCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span> <span class="o">-</span><span class="n">mc</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>

<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmWriter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="k">asm</span><span class="o">-</span><span class="n">writer</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="n">Cpu0AsmPrinter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="n">Cpu0MCInstLower</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
<span class="p">...</span>
<span class="n">add_subdirectory</span><span class="p">(</span><span class="n">InstPrinter</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  LLVMBuild.txt</span>
<span class="p">[</span><span class="n">common</span><span class="p">]</span>
<span class="n">subdirectories</span> <span class="o">=</span>
  <span class="n">InstPrinter</span>
  <span class="p">...</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="p">...</span>
<span class="cp"># Please enable asmprinter</span>
<span class="n">has_asmprinter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">...</span>

<span class="p">[</span><span class="n">component_1</span><span class="p">]</span>
<span class="cp"># Add AsmPrinter Cpu0AsmPrinter</span>
<span class="n">required_libraries</span> <span class="o">=</span>
                     <span class="n">AsmPrinter</span>
                     <span class="p">...</span>
                     <span class="n">Cpu0AsmPrinter</span>
                     <span class="p">...</span>
</pre></div>
</div>
<p>Now, run Chapter3_2/Cpu0 for AsmPrinter support, will get error message as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
/Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc: target does not
support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">llc</span></tt> fails to compile IR code into machine code since we didn&#8217;t implement
class Cpu0DAGToDAGISel. Before the implementation, we will introduce the LLVM
Code Generation Sequence, DAG, and LLVM instruction selection in next 3
sections.</p>
</div>
<div class="section" id="llvm-code-generation-sequence">
<h2>LLVM Code Generation Sequence<a class="headerlink" href="#llvm-code-generation-sequence" title="Permalink to this headline">¶</a></h2>
<p>Following diagram came from tricore_llvm.pdf.</p>
<div class="figure align-center" id="backendstructure-f5">
<img alt="_images/5.png" src="_images/5.png" />
<p class="caption">Figure 5: tricore_llvm.pdf: Code generation sequence. On the path from LLVM code to
assembly code, numerous passes are run through and several data structures
are used to represent the intermediate results.</p>
</div>
<p>LLVM is a Static Single Assignment (SSA) based representation.
LLVM provides an infinite virtual registers which can hold values of primitive
type (integral, floating point, or pointer values).
So, every operand can save in different virtual register in llvm SSA
representation.
Comment is “;” in llvm representation.
Following is the llvm SSA instructions.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">store</span> <span class="n">i32</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>  <span class="p">;</span> <span class="n">store</span> <span class="n">i32</span> <span class="n">type</span> <span class="n">of</span> <span class="mi">0</span> <span class="n">to</span> <span class="k">virtual</span> <span class="k">register</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span> <span class="n">is</span>
            <span class="p">;</span>  <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span> <span class="p">;</span> <span class="n">store</span> <span class="o">%</span><span class="n">b</span> <span class="n">contents</span> <span class="n">to</span> <span class="o">%</span><span class="n">c</span> <span class="n">point</span> <span class="n">to</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="n">isi32</span> <span class="n">type</span> <span class="k">virtual</span>
            <span class="p">;</span>  <span class="k">register</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="n">is</span> <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span><span class="p">.</span>
<span class="o">%</span><span class="n">a1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>    <span class="p">;</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">value</span> <span class="n">where</span> <span class="o">%</span><span class="n">a</span> <span class="n">point</span> <span class="n">to</span> <span class="n">and</span> <span class="n">assign</span> <span class="n">the</span>
            <span class="p">;</span>  <span class="n">memory</span> <span class="n">value</span> <span class="n">to</span> <span class="o">%</span><span class="n">a1</span>
<span class="o">%</span><span class="n">a3</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a2</span><span class="p">,</span> <span class="mi">1</span>  <span class="p">;</span> <span class="n">add</span> <span class="o">%</span><span class="n">a2</span> <span class="n">and</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">save</span> <span class="n">to</span> <span class="o">%</span><span class="n">a3</span>
</pre></div>
</div>
<p>We explain the code generation process as below.
If you don&#8217;t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can  read “The LLVM Target-Independent Code Generator” from <a class="footnote-reference" href="#id7" id="id3">[3]</a>
and “LLVM Language Reference Manual” from <a class="footnote-reference" href="#id8" id="id4">[4]</a>
before go ahead, but we think read section
4.2 of tricore_llvm.pdf is enough.
We suggest you read the web site documents as above only when you are still not
quite understand, even though you have read the articles of this section and
next 2 sections for DAG and Instruction Selection.</p>
<ol class="arabic simple">
<li>Instruction Selection</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
<span class="c1">//  still is llvm virtual operand.</span>
    <span class="n">store</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span> <span class="c1">// store 0 of i16 type to where virtual register %a</span>
               <span class="c1">//  point to</span>
<span class="o">=&gt;</span>  <span class="n">addiu</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Scheduling and Formation</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, reorder the instructions sequence for optimization in</span>
<span class="c1">//  instructions cycle or in register pressure.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span> <span class="c1">// st %a to *(%b+5)</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span>

<span class="c1">// Transfer above instructions order as follows. In RISC like Mips the ld %c use</span>
<span class="c1">//  the previous instruction st %c, must wait more than 1</span>
<span class="c1">// cycles. Meaning the ld cannot follow st immediately.</span>
<span class="o">=&gt;</span>  <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
<span class="c1">// If without reorder instructions, a instruction nop which do nothing must be</span>
<span class="c1">//  filled, contribute one instruction cycle more than optimization. (Actually,</span>
<span class="c1">//  Mips is scheduled with hardware dynamically and will insert nop between st</span>
<span class="c1">//  and ld instructions if compiler didn&#39;t insert nop.)</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">nop</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

<span class="c1">// Minimum register pressure</span>
<span class="c1">//  Suppose %c is alive after the instructions basic block (meaning %c will be</span>
<span class="c1">//  used after the basic block), %a and %b are not alive after that.</span>
<span class="c1">// The following no reorder version need 3 registers at least</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>

<span class="c1">// The reorder version need 2 registers only (by allocate %a and %b in the same</span>
<span class="c1">//  register)</span>
<span class="o">=&gt;</span> <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p class="first">SSA-based Machine Code Optimization</p>
<blockquote>
<div><p>For example, common expression remove, shown in next section DAG.</p>
</div></blockquote>
</li>
<li><p class="first">Register Allocation</p>
<blockquote>
<div><p>Allocate real register for virtual register.</p>
</div></blockquote>
</li>
<li><p class="first">Prologue/Epilogue Code Insertion</p>
<blockquote>
<div><p>Explain in section Add Prologue/Epilogue functions</p>
</div></blockquote>
</li>
<li><p class="first">Late Machine Code Optimizations</p>
<blockquote>
<div><p>Any “last-minute” peephole optimizations of the final machine code can be
applied during this phase.
For example, replace x = x * 2 by x = x &lt; 1 for integer operand.</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>Code Emission</dt>
<dd><p class="first last">Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</dd>
</dl>
</li>
</ol>
<p>The llvm code generation sequence also can be obtained by
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt> as the following. The first 4 code generation
sequences from <a class="pageref" href="#backendstructure-f5">Figure  5</a> are in the
<strong>&#8216;DAG-&gt;DAG Pattern Instruction Selection&#8217;</strong> of the <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt>
displayed. The order of Peephole Optimizations and Prologue/Epilogue Insertion
is inconsistent in them (please check the * in the following).
No need to bother since the the LLVM is under development and changed all the
time.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc --help-hidden
OVERVIEW: llvm system compiler

USAGE: llc <span class="o">[</span>options<span class="o">]</span> &lt;input bitcode&gt;

OPTIONS:
...
  -debug-pass                             - Print PassManager debugging <span class="nv">information</span>
    <span class="o">=</span>None                                 -   disable debug <span class="nv">output</span>
    <span class="o">=</span>Arguments                            -   print pass arguments to pass to <span class="s1">&#39;opt&#39;</span>
    <span class="o">=</span>Structure                            -   print pass structure before run<span class="o">()</span>
    <span class="o">=</span>Executions                           -   print pass name before it is <span class="nv">executed</span>
    <span class="o">=</span>Details                              -   print pass details when it is executed

118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc -march<span class="o">=</span>mips -debug-pass<span class="o">=</span>Structure ch3.bc
...
Target Library Information
Target Transform Info
Data Layout
Target Pass Configuration
No Alias Analysis <span class="o">(</span>always returns <span class="s1">&#39;may&#39;</span> <span class="nb">alias</span><span class="o">)</span>
Type-Based Alias Analysis
Basic Alias Analysis <span class="o">(</span>stateless AA impl<span class="o">)</span>
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    FunctionPass Manager
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Natural Loop Information
      Loop Pass Manager
        Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Canonicalize natural loops
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Exception handling preparation
      Optimize <span class="k">for </span>code generation
      Insert stack protectors
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Machine Function Analysis
      Natural Loop Information
      Branch Probability Analysis
    * MIPS DAG-&gt;DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
    * Peephole Optimizations
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      Eliminate PHI nodes <span class="k">for </span>register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Debug Variable Analysis
      Simple Register Coalescing
      Live Stack Slot Analysis
      Calculate spill weights
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
    * Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
    * Prologue/Epilogue Insertion &amp; Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
    * Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      Mips Delay Slot Filler
      Mips Long Branch
      MachineDominator Tree Construction
      Machine Natural Loop Construction
    * Mips Assembly Printer
      Delete Garbage Collector Information
</pre></div>
</div>
</div>
<div class="section" id="dag-directed-acyclic-graph">
<h2>DAG (Directed Acyclic Graph)<a class="headerlink" href="#dag-directed-acyclic-graph" title="Permalink to this headline">¶</a></h2>
<p>Many important techniques for local optimization begin by transforming a basic
block into DAG. For example, the basic block code and it&#8217;s corresponding DAG as
<a class="pageref" href="#backendstructure-f6">Figure  6</a>.</p>
<div class="figure align-center" id="backendstructure-f6">
<img alt="_images/6.png" src="_images/6.png" />
<p class="caption">Figure 6: DAG example</p>
</div>
<p>If b is not live on exit from the block, then we can do common expression
remove to get the following code.</p>
<div class="highlight-c++"><pre>a = b + c
d = a – d
c = d + c</pre>
</div>
<p>As you can imagine, the common expression remove can apply in IR or machine
code.</p>
<p>DAG like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
</div>
<div class="section" id="instruction-selection">
<h2>Instruction Selection<a class="headerlink" href="#instruction-selection" title="Permalink to this headline">¶</a></h2>
<p>In back end, we need to translate IR code into machine code at Instruction
Selection Process as <a class="pageref" href="#backendstructure-f7">Figure  7</a>.</p>
<div class="figure align-center" id="backendstructure-f7">
<img alt="_images/7.png" src="_images/7.png" />
<p class="caption">Figure 7: IR and it&#8217;s corresponding machine instruction</p>
</div>
<p>For machine instruction selection, the better solution is represent IR and
machine instruction by DAG.
In <a class="pageref" href="#backendstructure-f8">Figure  8</a>, we skip the register leaf.
The rj + rk is IR DAG representation (for symbol notation, not llvm SSA form).
ADD is machine instruction.</p>
<div class="figure align-center" id="backendstructure-f8">
<img alt="_images/8.png" src="_images/8.png" />
<p class="caption">Figure 8: Instruction DAG representation</p>
</div>
<p>The IR DAG and machine instruction DAG can also represented as list.
For example, (+ ri, rj), (- ri, 1) are lists for IR DAG; (ADD ri, rj),
(SUBI ri, 1) are lists for machine instruction DAG.</p>
<p>Now, let&#8217;s recall the ADDiu instruction defined on Cpu0InstrInfo.td in the
previous chapter. List them again as follows,</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0InstrFormats.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Format L instruction class in Cpu0 : &lt;|opcode|ra|rb|cx|&gt;</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs RC:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
     [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
...
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;</pre>
</div>
<p><a class="pageref" href="#backendstructure-f9">Figure  9</a> show how the pattern match work in the IR node
<strong>add</strong> and instruction ADDiu defined in Cpu0InstrInfo.td. This example
IR node &#8220;add %a, 5&#8221;, will be translated to &#8220;addiu %r1, 5&#8221; since the IR
pattern[(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))] is set in ADDiu and the
2nd operand is signed immediate which matched &#8220;%a, 5&#8221;. In addition to pattern
match, the .td also set assembly string &#8220;addiu&#8221; and op code 0x09.
With this information, the LLVM TableGen will generate instruction both in
assembly and binary automatically (the binary instruction in obj file of ELF
format which will shown at later chapter).
Similarly, the machine instruction DAG node LD and ST can be got from IR DAG
node <strong>load</strong> and <strong>store</strong>.</p>
<div class="figure align-center" id="backendstructure-f9">
<img alt="_images/9.png" src="_images/9.png" />
<p class="caption">Figure 9: Pattern match for ADDiu instruction and IR node add</p>
</div>
<p>Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-c++"><pre>def FMADDS : AForm_1&lt;59, 29,
          (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
          "fmadds $FRT, $FRA, $FRC, $FRB",
          [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                       F4RC:$FRB))]&gt;;</pre>
</div>
<p>Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include node <strong>fmul</strong> and node <strong>fadd</strong>.</p>
<p>Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">...</span>

<span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">fmul</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span>
<span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fadd</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The llvm SelectionDAG Optimization Phase (is part of Instruction Selection
Process) prefered to translate this 2 IR DAG node (fmul %a, %b) (fadd %d, %c)
into one machine instruction DAG node (<strong>fmadd</strong> %a, %c, %b), than translate
them into 2 machine instruction nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fmadd</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>As you can see, the IR notation representation is easier to read then llvm SSA
IR form.
So, we  use the notation form in this book sometimes.</p>
<p>For the following basic block code,</p>
<div class="highlight-c++"><pre>a = b + c   // in notation IR form
d = a – d
%e = fmadd %a, %c, %b // in llvm SSA IR form</pre>
</div>
<p>We can apply <a class="pageref" href="#backendstructure-f7">Figure  7</a> Instruction tree pattern to get the
following machine code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">load</span>  <span class="n">rb</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// assume b allocate in sp+8, sp is stack point register</span>
<span class="n">load</span>  <span class="n">rc</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span>
<span class="n">add</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">load</span>  <span class="n">rd</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">24</span><span class="p">);</span>
<span class="n">sub</span> <span class="n">rd</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">fmadd</span> <span class="n">re</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rb</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="add-cpu0dagtodagisel-class">
<h2>Add Cpu0DAGToDAGISel class<a class="headerlink" href="#add-cpu0dagtodagisel-class" title="Permalink to this headline">¶</a></h2>
<p>The IR DAG to machine instruction DAG transformation is introduced in the
previous section.
Now, let&#8217;s check what IR DAG nodes the file ch3.bc has. List ch3.ll as follows,</p>
<div class="highlight-c++"><pre>// ch3.ll
define i32 @main() nounwind uwtable {
%1 = alloca i32, align 4
store i32 0, i32* %1
ret i32 0
}</pre>
</div>
<p>As above, ch3.ll use the IR DAG node <strong>store</strong>, <strong>ret</strong>. Actually, it also use
<strong>add</strong> for sp (stack point) register adjust.
So, the definitions in Cpu0InstrInfo.td as follows is enough.
IR DAG is defined in file  include/llvm/Target/TargetSelectionDAG.td.</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>//===----------------------------------------------------------------------===//

/// Load and Store Instructions
///  aligned
defm LD     : LoadM32&lt;0x01,  "ld",  load_a&gt;;
defm ST     : StoreM32&lt;0x02, "st",  store_a&gt;;

/// Arithmetic Instructions (ALU Immediate)
// IR "add" defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1,
    isBarrier=1, hasCtrlDep=1 in
  def RET : FJ &lt;0x3c, (outs), (ins CPURegs:$target),
                "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch&gt;;

//===----------------------------------------------------------------------===//</pre>
</div>
<p>Add class Cpu0DAGToDAGISel (Cpu0ISelDAGToDAG.cpp) to CMakeLists.txt, and add
following fragment to Cpu0TargetMachine.cpp,</p>
<p class="rubric">lbdex/Chapter3_3/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(...</span>
  <span class="p">...</span>
  <span class="n">Cpu0ISelDAGToDAG</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>The following code in Cpu0TargetMachine.cpp will create a pass in instruction
selection stage.</p>
<p class="rubric">lbdex/Chapter3_3/Cpu0TargetMachine.cpp</p>
<p class="rubric">lbdex/Chapter3_3/Cpu0ISelDAGToDAG.cpp</p>
<p>This version adding the following code in Cpu0InstInfo.cpp to enable debug
information which called by llvm at proper time.</p>
<p class="rubric">lbdex/Chapter3_3/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="n">MachineInstr</span><span class="o">*</span> <span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                                 <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Offset</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                                 <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_3/Cpu0InstrInfo.cpp</p>
<p>Build Chapter3_3, run it, we find the error message in Chapter3_2 is gone.
The new error message for Chapter3_3 as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
...
LLVM ERROR: Cannot <span class="k">select</span>: 0x7f80f182d310: <span class="nv">ch</span> <span class="o">=</span> &lt;&lt;Unknown Target Node <span class="c">#190&gt;&gt;</span>
...
  0x7f80f182d210: <span class="nv">i32</span> <span class="o">=</span> Register %LR <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="handle-return-register-lr">
<h2>Handle return register lr<a class="headerlink" href="#handle-return-register-lr" title="Permalink to this headline">¶</a></h2>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrFormats.td</p>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrInfo.td</p>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrInfo.h</p>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrInfo.cpp</p>
<p>To handle IR ret, these code in Cpu0InstrInfo.td do things as below.</p>
<ol class="arabic simple">
<li>Declare a pseudo node to take care the IR Cpu0ISD::Ret by the following code,</li>
</ol>
<p class="rubric">lbdex/Chapter3_3/Cpu0InstrInfo.td</p>
<ol class="arabic simple" start="2">
<li>After instruction selection, the Cpu0::Ret is replaced by Cpu0::RetLR
as below. This effect came from &#8220;def RetLR&#8221; as step 1.</li>
</ol>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">=====</span> Instruction selection begins: BB#0 <span class="s1">&#39;entry&#39;</span>
Selecting: 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x1ea3f50, 0x1ea3e50,
0x1ea3f50:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>27<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret
0x1ea3f50, 0x1ea3e50, 0x1ea3f50:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>27<span class="o">]</span>

  Morphed node: 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> RetLR 0x1ea3e50, 0x1ea3f50, 0x1ea3f50:1
...
ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> RetLR 0x1ea3e50, 0x1ea3f50, 0x1ea3f50:1
...
<span class="o">=====</span> Instruction selection ends:
Selected selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 28 nodes:
...
    0x1ea3e50: &lt;multiple use&gt;
    0x1ea3f50: &lt;multiple use&gt;
    0x1ea3f50: &lt;multiple use&gt;
  0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> RetLR 0x1ea3e50, 0x1ea3f50, 0x1ea3f50:1
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>Expand the Cpu0::RetLR into instruction <strong>ret $lr</strong> in &#8220;Post-RA pseudo
instruction expansion pass&#8221; stage by the code in Chapter3_4/Cpu0InstrInfo.cpp
as above. This stage is after the register allocation, so we can replace the
V0 ($r2) by LR ($lr) without any side effect.</li>
<li>Print assembly or obj according the information (those *.inc generated by
TableGen from *.td) generated by the following code at &#8220;Cpu0 Assembly
Printer&#8221; stage.</li>
</ol>
<p class="rubric">lbdex/Chapter2/Cpu0InstrInfo.td</p>
<table border="1" class="docutils">
<caption>Handle return register lr</caption>
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Write Code</td>
<td>Declare a pseudo node Cpu0::RetLR</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>for IR Cpu0::Ret;</td>
</tr>
<tr class="row-even"><td>Instruction selection</td>
<td>Cpu0::Ret is replaced by Cpu0::RetLR</td>
</tr>
<tr class="row-odd"><td>Post-RA pseudo instruction expansion pass</td>
<td>Cpu0::RetLR -&gt; ret $lr</td>
</tr>
<tr class="row-even"><td>Cpu0 Assembly Printer</td>
<td>Print according &#8220;def RET&#8221;</td>
</tr>
</tbody>
</table>
<p>Build Chapter3_4, run it, we find the error message in Chapter3_3 is gone.
The new error message for Chapter3_4 as follows,</p>
<blockquote>
<div>118-165-78-230:InputFiles Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o
ch3.cpu0.s
...
Target didn&#8217;t implement TargetInstrInfo::storeRegToStackSlot!
1.  Running pass &#8216;Function Pass Manager&#8217; on module &#8216;ch3.bc&#8217;.
2.  Running pass &#8216;Prologue/Epilogue Insertion &amp; Frame Finalization&#8217; on function
&#8216;&#64;main&#8217;
...</div></blockquote>
</div>
<div class="section" id="add-prologue-epilogue-functions">
<h2>Add Prologue/Epilogue functions<a class="headerlink" href="#add-prologue-epilogue-functions" title="Permalink to this headline">¶</a></h2>
<p>Following came from tricore_llvm.pdf section “4.4.2 Non-static Register
Information ”.</p>
<p>For some target architectures, some aspects of the target architecture’s
register set are dependent upon variable factors and have to be determined at
runtime.
As a consequence, they cannot be generated statically from a TableGen
description – although that would be possible for the bulk of them in the case
of the TriCore backend.
Among them are the following points:</p>
<ul class="simple">
<li>Callee-saved registers. Normally, the ABI specifies a set of registers that a
function must save on entry and restore on return if their contents are
possibly modified during execution.</li>
<li>Reserved registers. Although the set of unavailable registers is already
defined in the TableGen file, TriCoreRegisterInfo contains a method that marks
all non-allocatable register numbers in a bit vector.</li>
</ul>
<p>The following methods are implemented:</p>
<ul class="simple">
<li>emitPrologue() inserts prologue code at the beginning of a function. Thanks
to TriCore’s context model, this is a trivial task as it is not required to
save any registers manually. The only thing that has to be done is reserving
space for the function’s stack frame by decrementing the stack pointer.
In addition, if the function needs a frame pointer, the frame register %a14 is
set to the old value of the stack pointer beforehand.</li>
<li>emitEpilogue() is intended to emit instructions to destroy the stack frame
and restore all previously saved registers before returning from a function.
However, as %a10 (stack pointer), %a11 (return address), and %a14 (frame
pointer, if any) are all part of the upper context, no epilogue code is needed
at all. All cleanup operations are performed implicitly by the ret instruction.</li>
<li>eliminateFrameIndex() is called for each instruction that references a word
of data in a stack slot. All previous passes of the code generator have been
addressing stack slots through an abstract frame index and an immediate offset.
The purpose of this function is to translate such a reference into a
register–offset pair. Depending on whether the machine function that contains
the instruction has a fixed or a variable stack frame, either the stack pointer
%a10 or the frame pointer %a14 is used as the base register.
The offset is computed accordingly.
<a class="pageref" href="#backendstructure-f10">Figure  10</a> demonstrates for both cases how a stack slot
is addressed.</li>
</ul>
<p>If the addressing mode of the affected instruction cannot handle the address
because the offset is too large (the offset field has 10 bits for the BO
addressing mode and 16 bits for the BOL mode), a sequence of instructions is
emitted that explicitly computes the effective address.
Interim results are put into an unused address register.
If none is available, an already occupied address register is scavenged.
For this purpose, LLVM’s framework offers a class named RegScavenger that
takes care of all the details.</p>
<div class="figure align-center" id="backendstructure-f10">
<img alt="_images/10.png" src="_images/10.png" />
<p class="caption">Figure 10: Addressing of a variable a located on the stack.
If the stack frame has a variable size, slot must be addressed relative to
the frame pointer</p>
</div>
<p>We will explain the Prologue and Epilogue further by example code.
So for the following llvm IR code, Cpu0 back end will emit the corresponding
machine instructions as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
  %1 <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %1
  ret i32 0
<span class="o">}</span>

  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main//static void expandLargeImm<span class="se">\\</span>n
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>LLVM get the stack size by parsing IR and counting how many virtual registers
is assigned to local variables. After that, it call emitPrologue().
This function will emit machine instructions to adjust sp (stack pointer
register) for local variables since we don&#8217;t use fp (frame pointer register).
For our example, it will emit the instructions,</p>
<div class="highlight-c++"><pre>addiu $sp, $sp, -8</pre>
</div>
<p>The  emitEpilogue will emit “addiu  $sp, $sp, 8”, where 8 is the stack size.</p>
<p>Since Instruction Selection and Register Allocation occurs before
Prologue/Epilogue Code Insertion, eliminateFrameIndex() is called after machine
instruction and real register allocated.
It translate the frame index of local variable (%1 and %2 in the following
example) into stack offset according the frame index order upward (stack grow
up downward from high address to low address, 0($sp) is the top, 52($sp) is the
bottom) as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
     %1 <span class="o">=</span> alloca i32, align 4
     %2 <span class="o">=</span> alloca i32, align 4
    ...
    store i32 0, i32* %1
    store i32 5, i32* %2, align 4
    ...
    ret i32 <span class="nv">0</span>

<span class="o">=</span>&gt; <span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -56
<span class="nv">$tmp1</span>:
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$3</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %1 is the first frame index <span class="nb">local </span>variable, so allocate
                    // in 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %2 is the second frame index <span class="nb">local </span>variable, so
                    // allocate in 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ...
  ret <span class="nv">$lr</span>
</pre></div>
</div>
<p>The Prologue and Epilogue functions as follows,</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0FrameLowering.h</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">processFunctionBeforeCalleeSavedScan</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                          <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_5/Cpu0FrameLowering.cpp</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0AnalyzeImmediate.h</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0AnalyzeImmediate.cpp</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0RegisterInfo.cpp</p>
<p>Add these instructions to Cpu0InstrInfo.td which used in Prologue and Epilogue
functions.</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def shamt       : Operand&lt;i32&gt;;

// Unsigned Operand
def uimm16      : Operand&lt;i32&gt; {
  let PrintMethod = "printUnsignedImm";
}
...
// Transformation Function - get the lower 16 bits.
def LO16 : SDNodeXForm&lt;imm, [{
  return getImm(N, N-&gt;getZExtValue() &amp; 0xffff);
}]&gt;;

// Transformation Function - get the higher 16 bits.
def HI16 : SDNodeXForm&lt;imm, [{
  return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xffff);
}]&gt;; // lbd document - mark - def HI16
...
// Node immediate fits as 16-bit zero extended on target immediate.
// The LO16 param means that only the lower 16 bits of the node
// immediate are caught.
// e.g. addiu, sltiu
def immZExt16  : PatLeaf&lt;(imm), [{
  if (N-&gt;getValueType(0) == MVT::i32)
    return (uint32_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
  else
    return (uint64_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
}], LO16&gt;;

// Immediate can be loaded with LUi (32-bit int with lower 16-bit cleared).
def immLow16Zero : PatLeaf&lt;(imm), [{
  int64_t Val = N-&gt;getSExtValue();
  return isInt&lt;32&gt;(Val) &amp;&amp; !(Val &amp; 0xffff);
}]&gt;;

// shamt field must fit in 5 bits.
def immZExt5 : ImmLeaf&lt;i32, [{return Imm == (Imm &amp; 0x1f);}]&gt;;
...
// Arithmetic and logical instructions with 3 register operands.
class ArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
     [(set RC:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;  // e.g. add rb rc =  add rc rb
  let isReMaterializable = 1;
}
...
// Shifts
class shift_rotate_imm&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                       SDNode OpNode, PatFrag PF, Operand ImmOpnd,
                       RegisterClass RC&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, ImmOpnd:$shamt),
     !strconcat(instr_asm, "\t$ra, $rb, $shamt"),
     [(set RC:$ra, (OpNode RC:$rb, PF:$shamt))], IIAlu&gt; {
  let rc = 0;
  let shamt = shamt;
}

// 32-bit shift instructions.
class shift_rotate_imm32&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                         SDNode OpNode&gt;:
  shift_rotate_imm&lt;op, isRotate, instr_asm, OpNode, immZExt5, shamt, CPURegs&gt;;

// Load Upper Imediate
class LoadUpper&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC, Operand Imm&gt;:
  FL&lt;op, (outs RC:$ra), (ins Imm:$imm16),
     !strconcat(instr_asm, "\t$ra, $imm16"), [], IIAlu&gt; {
  let rb = 0;
  let neverHasSideEffects = 1;
  let isReMaterializable = 1;
} // lbd document - mark - class LoadUpper
...
def ORi     : ArithLogicI&lt;0x0d, "ori", or, uimm16, immZExt16, CPURegs&gt;;
def LUi     : LoadUpper&lt;0x0f, "lui", CPURegs, uimm16&gt;;

/// Arithmetic Instructions (3-Operand, R-Type)
def ADDu    : ArithLogicR&lt;0x11, "addu", add, IIAlu, CPURegs, 1&gt;;

/// Shift Instructions
def SHL     : shift_rotate_imm32&lt;0x1e, 0x00, "shl", shl&gt;;
...
def : Pat&lt;(i32 immZExt16:$in),
          (ORi ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immLow16Zero:$in),
          (LUi (HI16 imm:$in))&gt;;

// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
          (ORi (LUi (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;</pre>
</div>
<p class="rubric">lbdex/Chapter3_5/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(...</span>
  <span class="p">...</span>
  <span class="n">Cpu0AnalyzeImmediate</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>After add these Prologue and Epilogue functions, and build with Chapter3_5/Cpu0.
Now we are ready to compile our example code ch3.bc into cpu0 assembly code.
Following is the command and output file ch3.cpu0.s,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
Args: /Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o ch3.cpu0.s
118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>cat ch3.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>To see how the <strong>&#8216;DAG-&gt;DAG Pattern Instruction Selection&#8217;</strong> work in llc, let&#8217;s
compile with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> option and see what happens.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
Args: /Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
...
Optimized legalized selection DAG: BB#0 <span class="s1">&#39;main:&#39;</span>
SelectionDAG has 8 nodes:
  0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

  0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>

      0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

      0x7fbe4082d010: &lt;multiple use&gt;
      0x7fbe4082d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>2<span class="o">]</span>

      0x7fbe4082d210: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>

    0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668, 0x7fbe4082d010, 0x7fbe4082d110,
    0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

    0x7fbe4082d410: &lt;multiple use&gt;
    0x7fbe4082d010: &lt;multiple use&gt;
  0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
  0x7fbe4082d010 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>

    0x7fbe4082d510: &lt;multiple use&gt;
    0x7fbe4082d410: &lt;multiple use&gt;
    0x7fbe4082d510: &lt;multiple use&gt;
  0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fbe4082d510, 0x7fbe4082d410,
  0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>


<span class="o">=====</span> Instruction selection begins: BB#0 <span class="s1">&#39;&#39;</span>
Selecting: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fbe4082d510, 0x7fbe4082d410,
0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret
0x7fbe4082d510, 0x7fbe4082d410, 0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

  Morphed node: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> RET 0x7fbe4082d410, 0x7fbe4082d510,
  0x7fbe4082d510:1

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> RET 0x7fbe4082d410, 0x7fbe4082d510, 0x7fbe4082d510:1

Selecting: 0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
0x7fbe4082d010 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
0x7fbe4082d010

Selecting: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668, 0x7fbe4082d010,
0x7fbe4082d110, 0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668,
0x7fbe4082d010, 0x7fbe4082d110, 0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

  Initial Opcode index to 166
  Morphed node: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> ST 0x7fbe4082d010, 0x7fbe4082d710,
  0x7fbe4082d810, 0x7fbe40410668&lt;Mem:ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> ST 0x7fbe4082d010, 0x7fbe4082d710, 0x7fbe4082d810,
0x7fbe40410668&lt;Mem:ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

Selecting: 0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0

Selecting: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span>
Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

  Initial Opcode index to 1201
  Morphed node: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> ADDiu 0x7fbe4082d110, 0x7fbe4082d810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> ADDiu 0x7fbe4082d110, 0x7fbe4082d810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

Selecting: 0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

<span class="o">=====</span> Instruction selection ends:
</pre></div>
</div>
<p>Summary above translation into Table: Chapter 3 .bc IR instructions.</p>
<table border="1" class="docutils">
<caption>Chapter 3 .bc IR instructions</caption>
<colgroup>
<col width="40%" />
<col width="47%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">.bc</th>
<th class="head">Optimized legalized selection DAG</th>
<th class="head">Cpu0</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>constant 0</td>
<td>constant 0</td>
<td>addiu</td>
</tr>
<tr class="row-odd"><td>store</td>
<td>store</td>
<td>st</td>
</tr>
<tr class="row-even"><td>ret</td>
<td>Cpu0ISD::Ret</td>
<td>ret</td>
</tr>
</tbody>
</table>
<p>From above <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> display, we see the <strong>store</strong> and <strong>ret</strong> are
translated into <strong>store</strong> and <strong>Cpu0ISD::Ret</strong> in stage Optimized legalized
selection DAG, and then translated into Cpu0 instructions <strong>st</strong> and <strong>ret</strong>
finally.
Since store use <strong>constant 0</strong> (<strong>store i32 0, i32* %1</strong> in this example), the
constant 0 will be translated into <strong>&#8220;addiu $2, $zero, 0&#8221;</strong> via the following
pattern defined in Cpu0InstrInfo.td.</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Small immediates
def : Pat&lt;(i32 immSExt16:$in),
          (ADDiu ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immZExt16:$in),
          (ORi ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immLow16Zero:$in),
          (LUi (HI16 imm:$in))&gt;;

// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
          (ORi (LUi (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;</pre>
</div>
<p>At this point, we have translated the very simple main() function with return 0
single instruction. The Cpu0AnalyzeImmediate.cpp defined as above and the
Cpu0InstrInfo.td instructions add as below, which takes care
the 32 bits stack size adjustments.</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def shamt       : Operand&lt;i32&gt;;

// Unsigned Operand
def uimm16      : Operand&lt;i32&gt; {
  let PrintMethod = "printUnsignedImm";
}
...
// Transformation Function - get the lower 16 bits.
def LO16 : SDNodeXForm&lt;imm, [{
  return getImm(N, N-&gt;getZExtValue() &amp; 0xffff);
}]&gt;;

// Transformation Function - get the higher 16 bits.
def HI16 : SDNodeXForm&lt;imm, [{
  return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xffff);
}]&gt;;
...
// Node immediate fits as 16-bit zero extended on target immediate.
// The LO16 param means that only the lower 16 bits of the node
// immediate are caught.
// e.g. addiu, sltiu
def immZExt16  : PatLeaf&lt;(imm), [{
  if (N-&gt;getValueType(0) == MVT::i32)
    return (uint32_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
  else
    return (uint64_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
}], LO16&gt;;

// Immediate can be loaded with LUi (32-bit int with lower 16-bit cleared).
def immLow16Zero : PatLeaf&lt;(imm), [{
  int64_t Val = N-&gt;getSExtValue();
  return isInt&lt;32&gt;(Val) &amp;&amp; !(Val &amp; 0xffff);
}]&gt;;

// shamt field must fit in 5 bits.
def immZExt5 : ImmLeaf&lt;i32, [{return Imm == (Imm &amp; 0x1f);}]&gt;;
...
// Arithmetic and logical instructions with 3 register operands.
class ArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
     [(set RC:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;  // e.g. add rb rc =  add rc rb
  let isReMaterializable = 1;
}
...

// Shifts
class shift_rotate_imm&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                       SDNode OpNode, PatFrag PF, Operand ImmOpnd,
                       RegisterClass RC&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, ImmOpnd:$shamt),
     !strconcat(instr_asm, "\t$ra, $rb, $shamt"),
     [(set RC:$ra, (OpNode RC:$rb, PF:$shamt))], IIAlu&gt; {
  let rc = isRotate;
  let shamt = shamt;
}

// 32-bit shift instructions.
class shift_rotate_imm32&lt;bits&lt;8&gt; func, bits&lt;4&gt; isRotate, string instr_asm,
                         SDNode OpNode&gt;:
  shift_rotate_imm&lt;func, isRotate, instr_asm, OpNode, immZExt5, shamt, CPURegs&gt;;

// Load Upper Imediate
class LoadUpper&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC, Operand Imm&gt;:
  FL&lt;op, (outs RC:$ra), (ins Imm:$imm16),
     !strconcat(instr_asm, "\t$ra, $imm16"), [], IIAlu&gt; {
  let rb = 0;
  let neverHasSideEffects = 1;
  let isReMaterializable = 1;
}
...
def ORi     : ArithLogicI&lt;0x0d, "ori", or, uimm16, immZExt16, CPURegs&gt;;
def LUi     : LoadUpper&lt;0x0f, "lui", CPURegs, uimm16&gt;;

/// Arithmetic Instructions (3-Operand, R-Type)
def ADDu    : ArithLogicR&lt;0x11, "addu", add, IIAlu, CPURegs, 1&gt;;

/// Shift Instructions
def SHL     : shift_rotate_imm32&lt;0x1e, 0x00, "shl", shl&gt;;
...

// Small immediates
...
def : Pat&lt;(i32 immZExt16:$in),
          (ORi ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immLow16Zero:$in),
          (LUi (HI16 imm:$in))&gt;;

// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
          (ORi (LUi (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;</pre>
</div>
<p>The Cpu0AnalyzeImmediate.cpp written in recursive and a little complicate in
logic. Anyway, the recursive
skills is used in the front end compile book, you should fimiliar with it.
Instead tracking the code, listing the stack size and the instructions
generated in Table: Cpu0 stack adjustment instructions before replace addiu and
shl with lui instruction as follows (Cpu0 stack adjustment instructions after
replace addiu and shl with lui instruction as below),</p>
<table border="1" class="docutils">
<caption>Cpu0 stack adjustment instructions before replace addiu and shl with lui instruction</caption>
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">stack size range</th>
<th class="head">ex. stack size</th>
<th class="head">Cpu0 Prologue instructions</th>
<th class="head">Cpu0 Epilogue instructions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0 ~ 0x7fff</td>
<td><ul class="first last simple">
<li>0x7fff</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, 32767;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, 32767;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>0x8000 ~ 0xffff</td>
<td><ul class="first last simple">
<li>0x8000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, -32768;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, 1;</li>
<li>shl $1, $1, 16;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>x10000 ~ 0xffffffff</td>
<td><ul class="first last simple">
<li>0x7fffffff</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -1;</li>
<li>shl $1, $1, 31;</li>
<li>addiu $1, $1, 1;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, 1;</li>
<li>shl $1, $1, 31;</li>
<li>addiu $1, $1, -1;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>x10000 ~ 0xffffffff</td>
<td><ul class="first last simple">
<li>0x90008000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -9;</li>
<li>shl $1, $1, 28;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -28671;</li>
<li>shl $1, $1, 16</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Assume sp = 0xa0008000 and stack size = 0x90008000, then (0xa0008000 -
0x90008000) =&gt; 0x10000000. Verify with the Cpu0 Prologue instructions as
follows,</p>
<ol class="arabic simple">
<li>&#8220;addiu       $1, $zero, -9&#8221; =&gt; ($1 = 0 + 0xfffffff7) =&gt; $1 = 0xfffffff7.</li>
<li>&#8220;shl $1, $1, 28;&#8221; =&gt; $1 = 0x70000000.</li>
<li>&#8220;addiu       $1, $1, -32768&#8221; =&gt; $1 = (0x70000000 + 0xffff8000) =&gt; $1 = 0x6fff8000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0xa0008000 + 0x6fff8000) =&gt; $sp = 0x10000000.</li>
</ol>
<p>Verify with the Cpu0 Epilogue instructions with sp = 0x10000000 and stack size =
0x90008000 as follows,</p>
<ol class="arabic simple">
<li>&#8220;addiu       $1, $zero, -28671&#8221; =&gt; ($1 = 0 + 0xffff9001) =&gt; $1 = 0xffff9001.</li>
<li>&#8220;shl $1, $1, 16;&#8221; =&gt; $1 = 0x90010000.</li>
<li>&#8220;addiu       $1, $1, -32768&#8221; =&gt; $1 = (0x90010000 + 0xffff8000) =&gt; $1 = 0x90008000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0x10000000 + 0x90008000) =&gt; $sp = 0xa0008000.</li>
</ol>
<p>The Cpu0AnalyzeImmediate::GetShortestSeq() will call Cpu0AnalyzeImmediate::
ReplaceADDiuSHLWithLUi() to replace addiu and shl with single instruction lui
only. The effect as the following table.</p>
<table border="1" class="docutils">
<caption>Cpu0 stack adjustment instructions after replace addiu and shl with lui instruction</caption>
<colgroup>
<col width="5%" />
<col width="18%" />
<col width="15%" />
<col width="31%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
<th class="head">&nbsp;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>old</td>
<td>x10000 ~ 0xffffffff</td>
<td><ul class="first last simple">
<li>0x90008000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -9;</li>
<li>shl $1, $1, 28;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -28671;</li>
<li>shl $1, $1, 16</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>new</td>
<td>x10000 ~ 0xffffffff</td>
<td><ul class="first last simple">
<li>0x90008000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>lui $1, 28671;</li>
<li>ori $1, $1, 32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>lui     $1, 36865;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Assume sp = 0xa0008000 and stack size = 0x90008000, then (0xa0008000 -
0x90008000) =&gt; 0x10000000. Verify with the Cpu0 Prologue instructions as
follows,</p>
<ol class="arabic simple">
<li>&#8220;lui $1, 28671&#8221; =&gt; $1 = 0x6fff0000.</li>
<li>&#8220;ori $1, $1, 32768&#8221; =&gt; $1 = (0x6fff0000 + 0x00008000) =&gt; $1 = 0x6fff8000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0xa0008000 + 0x6fff8000) =&gt; $sp = 0x10000000.</li>
</ol>
<p>Verify with the Cpu0 Epilogue instructions with sp = 0x10000000 and stack size =
0x90008000 as follows,</p>
<ol class="arabic simple">
<li>&#8220;lui $1, 36865&#8221; =&gt; $1 = 0x90010000.</li>
<li>&#8220;addiu $1, $1, -32768&#8221; =&gt; $1 = (0x90010000 + 0xffff8000) =&gt; $1 = 0x90008000.</li>
<li>&#8220;addu $sp, $sp, $1&#8221; =&gt; $sp = (0x10000000 + 0x90008000) =&gt; $sp = 0xa0008000.</li>
</ol>
</div>
<div class="section" id="summary-of-this-chapter">
<h2>Summary of this Chapter<a class="headerlink" href="#summary-of-this-chapter" title="Permalink to this headline">¶</a></h2>
<p>Summary the functions for llvm backend stages as the following table.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc
-debug-pass<span class="o">=</span>Structure -o -
...
Machine Branch Probability Analysis
  ModulePass Manager
    FunctionPass Manager
      ...
      CPU0 DAG-&gt;DAG Pattern Instruction Selection
        Initial selection DAG
        Optimized lowered selection DAG
        Type-legalized selection DAG
        Optimized <span class="nb">type</span>-legalized selection DAG
        Legalized selection DAG
        Optimized legalized selection DAG
        Instruction selection
        Selected selection DAG
        Scheduling
      ...
      Greedy Register Allocator
      ...
      Post-RA pseudo instruction expansion pass
      ...
      Cpu0 Assembly Printer
</pre></div>
</div>
<table border="1" class="docutils">
<caption>functions for llvm backend stage</caption>
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Before CPU0 DAG-&gt;DAG Pattern Instruction Selection</td>
<td><ul class="first last simple">
<li>Cpu0TargetLowering::LowerFormalArguments</li>
<li>Cpu0TargetLowering::LowerReturn</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>Instruction selection</td>
<td><ul class="first last simple">
<li>Cpu0DAGToDAGISel::Select</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>Prologue/Epilogue Insertion &amp; Frame Finalization</td>
<td><ul class="first last simple">
<li>Cpu0FrameLowering.cpp</li>
<li>Cpu0RegisterInfo::eliminateFrameIndex()</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>Cpu0 Assembly Printer</td>
<td><ul class="first last simple">
<li>Cpu0AsmPrinter.cpp -&gt; Cpu0MCInstLower.cpp</li>
<li>Cpu0InstPrinter.cpp</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>We add a pass in Instruction Section stage in section &#8220;Add Cpu0DAGToDAGISel
class&#8221;. You can embed your code into other pass like that. Please check
CodeGen/Passes.h for the information. Remember the pass is called according
the function unit as the <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt> indicated.</p>
<p>We have finished a simple assembler for cpu0 which only support <strong>ld</strong>,
<strong>st</strong>, <strong>addiu</strong>, <strong>ori</strong>, <strong>lui</strong>, <strong>addu</strong>, <strong>shl</strong> and <strong>ret</strong> 8
instructions.</p>
<p>We are satisfied with this result.
But you may think “After so many codes we program, and just get these 8
instructions”.
The point is we have created a frame work for cpu0 target machine (please
look back the llvm back end structure class inherit tree early in this
chapter).
Until now, we have over 3000 lines of source code with comments which include
files *.cpp, *.h, *.td, CMakeLists.txt and LLVMBuild.txt.
It can be counted by command <tt class="docutils literal"><span class="pre">wc</span> <span class="pre">`find</span> <span class="pre">dir</span> <span class="pre">-name</span> <span class="pre">*.cpp`</span></tt> for files *.cpp,
*.h, *.td, *.txt.
LLVM front end tutorial have 700 lines of source code without comments totally.
Don&#8217;t feel down with this result.
In reality, write a back end is warm up slowly but run fast.
Clang has over 500,000 lines of source code with comments in clang/lib
directory which include C++ and Obj C support.
Mips back end has only 15,000 lines with comments.
Even the complicate X86 CPU which CISC outside and RISC inside (micro
instruction), has only 45,000 lines with comments.
In next chapter, we will show you that add a new instruction support is as easy
as 123.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Arithmetic and logic lsupport</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>